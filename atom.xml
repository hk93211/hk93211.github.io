<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kwin &#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/497e53aa320bd8552ff00799066f170e</icon>
  <subtitle>不会搞艺术的程序员不是好设计师</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://huangkun.host/"/>
  <updated>2020-12-31T08:09:40.591Z</updated>
  <id>http://huangkun.host/</id>
  
  <author>
    <name>Kwin</name>
    <email>hk93211@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>h5与原生APP交互原理</title>
    <link href="http://huangkun.host/2020/12/31/20201223-h5%E4%B8%8E%E5%8E%9F%E7%94%9FAPP%E4%BA%A4%E4%BA%92%E5%8E%9F%E7%90%86/"/>
    <id>http://huangkun.host/2020/12/31/20201223-h5%E4%B8%8E%E5%8E%9F%E7%94%9FAPP%E4%BA%A4%E4%BA%92%E5%8E%9F%E7%90%86/</id>
    <published>2020-12-31T08:07:28.699Z</published>
    <updated>2020-12-31T08:09:40.591Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文将深入探讨 H5 与 App 交互的几种常见模式。</p><p>首先声明，本文涉及的 H5 与 App 交互协议和模式没有什么特别独到之处，相反，它们恰恰是在业界既有经验基础上结合项目实际归纳提炼出来的。因此，文中涉及的技术和代码可以看作是行业经验落地的产物，不涉秘，也不是权威做法，仅供业界同仁参考。</p><p>本文内容如下：</p><ul><li>概述</li><li>基础接口</li><li>单向调用</li><li>双向调用</li><li>实现模式</li><li>哪方主导</li></ul><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><hr><p>H5，在中国被专门用来指代开发内嵌于手机应用中的网页的技术，外国好像并没有这个说法。从技术上讲，H5 是 HTML5 即 Hyper Text Markup Language（超文本标记语言）第 5 版的简称。而 HTML 只是开发网页要用到的多种技术之一。除了 HTML，还要用 CSS 设计界面，用 JavaScript 实现交互，甚至要用 Node.js 实现服务端逻辑。为什么 H5 会被用来笼统地指代这些技术呢？我猜一是因为它简单，二是移动端网页开发技术又恰好需要这么一个概念。</p><p>移动端网页运行在手机应用内嵌的浏览器引擎中，这个没有 UI 的内核容器统称 WebView，即 <a href="https://developer.apple.com/documentation/uikit/uiwebview" target="_blank" rel="noopener">iPhone 的 UIWebView</a>（iOS 2.0–12.0）、<a href="https://developer.apple.com/documentation/webkit/wkwebview" target="_blank" rel="noopener">WKWebView</a>（iOS 8.0+，macOS 10.10+）和 <a href="https://developer.android.com/reference/android/webkit/WebView" target="_blank" rel="noopener">Android 的 WebView</a>。总之，WebView 就是在手机应用中运行和展示网页的界面和接口（神奇的是，英文 Interface，既可以翻译成 “界面” 也可以翻译成“接口”）。</p><p>H5 与原生应用的交互都是通过原生应用中的 WebView 实现的。通过这个环境，H5 可以调用原生应用注入其中的原生对象的方法，原生应用也可以调用 H5 暴露在这个环境中的 JavaScript 对象的方法，从而实现指令与数据的传输。</p><p>比如，在 Android 应用中，<code>WebView</code>类有一个公有方法<code>addJavascriptInterface</code>，签名为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> addJavascriptInterface (<span class="built_in">Object</span> object, <span class="built_in">String</span> name)</span><br></pre></td></tr></table></figure><p>调用这个方法可以向 WebView 中以指定的名称<code>name</code>注入指定的 Java 对象<code>object</code>。这样，WebView 中的 JavaScript 就可以通过<code>name</code>调用<code>object</code>的方法。比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JsObject</span> </span>&#123;</span><br><span class="line">    @JavascriptInterface</span><br><span class="line">    public <span class="built_in">String</span> toString() &#123; <span class="keyword">return</span> <span class="string">"injectedObject"</span>; &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> webview.getSettings().setJavaScriptEnabled(<span class="literal">true</span>);</span><br><span class="line"> webView.addJavascriptInterface(<span class="keyword">new</span> JsObject(), <span class="string">"injectedObject"</span>);</span><br><span class="line"> webView.loadData(<span class="string">""</span>, <span class="string">"text/html"</span>, <span class="literal">null</span>);</span><br><span class="line"> webView.loadUrl(<span class="string">"javascript:alert(injectedObject.toString())"</span>);</span><br></pre></td></tr></table></figure><p>在 iOS 或 macOS 中，需要通过创建<code>WKWebView</code>类的实例在应用中嵌入网页，交互过程类似。</p><h2 id="基础接口"><a href="#基础接口" class="headerlink" title="基础接口"></a>基础接口</h2><hr><p>所谓基础接口，就是首先要规定原生应用和 JS 分别在 WebView 里注入 / 暴露一个什么对象：</p><ul><li><code>NativeBridge</code>：原生应用注入到 WebView 中的对象</li><li><code>JSBridge</code>：JS 暴露在 WebView 中的对象</li></ul><p>并约定在这两个对象上分别可以调用什么方法：</p><ul><li><code>NativeBridge.callNative(action, params, whoCare)</code></li><li><code>JSBridge.callJS(action, params, whoAmI)</code></li></ul><p>顾名思义，<code>NativeBridge.callNative</code>是由 JS 调用向 Native 传递指令或数据的方法，而<code>JSBridge.callJS</code>则是由 Native 调用向 JS 传递指令或数据的方法。方法签名中的参数含义如下：</p><ul><li><code>action</code>：字符串，希望 Native/JS 执行的操作</li><li><code>params</code>：JSON 对象，要传给 Native/JS 的数据</li><li><code>whoCare</code>：数值，表示 JS 希望哪个端响应</li><li><code>whoAmI</code>：数值，表示哪个端调用的 JS</li></ul><p>基础接口只有两个对象和两个方法，JS 与 App 间的互操作则通过<code>action</code>和<code>params</code>来扩展和定义。</p><h2 id="实现模式"><a href="#实现模式" class="headerlink" title="实现模式"></a>实现模式</h2><hr><p>对于 JS 而言，虽然这里只定义了一个对象一个方法，但实践中，可以把<code>action</code>对应方法的实现附加到<code>JSBridge</code>上，只要把<code>callJS</code>实现为一个分发方法即可，比如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.JSBridge = &#123;&#125;</span><br><span class="line"><span class="built_in">window</span>.JSBridge.callJS = <span class="function"><span class="keyword">function</span>(<span class="params">&#123;action, params, whoAmI&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">window</span>.JSBridge[action](params, whoAmI)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，所有对<code>callJS</code>的调用，都会转化成对<code>JSBridge</code>上相应<code>action</code>方法的调用，优点是只需一行代码。</p><p>另一种实现方式是通过<code>switch...case</code>语句实现调用分发，比如:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callJS</span> (<span class="params">action, params, whoAmI</span>) </span>&#123;</span><br><span class="line">  params = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(params))</span><br><span class="line">  <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'showSkill'</span>:</span><br><span class="line">      <span class="keyword">const</span> category = params.category</span><br><span class="line">      JSBridge.showSkill(category)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'showSkillDetail'</span>:</span><br><span class="line">      <span class="keyword">const</span> id = params.id</span><br><span class="line">      JSBridge.showSkillDetail(id)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'otherAction'</span>:</span><br><span class="line">      <span class="comment">// some code</span></span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// JS暴露给应用的通用接口</span></span><br><span class="line"><span class="keyword">const</span> SpkJSBridge = &#123;&#125;</span><br><span class="line"><span class="comment">// 全部接口</span></span><br><span class="line">JSBridge.callJS = callJS</span><br></pre></td></tr></table></figure><p>这样实现的优点是所有方法一目了然，当然同样也是把所有相关接口都附加到同一个<code>JSBridge</code>对象上。</p><p>以上两种实现模式各有利弊。</p><h2 id="单向调用"><a href="#单向调用" class="headerlink" title="单向调用"></a>单向调用</h2><hr><p>由 JS 发起的单向调用 App 的操作，主要涉及加载 URL 和切换到原生界面，可对应如下<code>action</code>：</p><ul><li><code>loadUrl</code>：加载另一个 URL</li><li><code>loadContent</code>：跳转到原生界面</li></ul><p><code>loadUrl</code>调用的参考协议如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">NativeBridge.callNative(&#123;</span><br><span class="line">    action: <span class="string">'loadUrl'</span>,</span><br><span class="line">    params: &#123; url &#125;,</span><br><span class="line">    whoCare: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里<code>NativeBridge</code>是 App 的原生对象，其<code>callNative</code>方法被调用时，会收到一个对象（字典 / 映射）参数。根据这个参数的<code>action</code>属性的值，App 可知需要执行的操作是加载 URL。于是再取得<code>params</code>属性中的<code>url</code>，发送请求即可。</p><p><code>loadContent</code>调用的参考协议如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">NativeBridge.callNative(&#123;</span><br><span class="line">  action: <span class="string">"loadContent"</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">"album"</span>,</span><br><span class="line">    content: &#123;</span><br><span class="line">      album_id: <span class="string">"1"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  whoCare: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>同上，这里通过<code>params</code>向 App 传递了必要参数，App 负责切换到相应的原生界面。</p><p>由 App 发起的单向调用 JS 的操作，主要涉及用户点击后退按钮（&lt;），可对应如下<code>action</code>：</p><ul><li><code>can_back</code>：询问 JS 是否返回前是否需要用户确认</li></ul><p><code>can_back</code>调用的参考协议如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JSBridge.callJS(&#123;</span><br><span class="line">  action: <span class="string">"can_back"</span>,</span><br><span class="line">  params: &#123;&#125;,</span><br><span class="line">  whoAmI: <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>此调用返回的值示例如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  can: <span class="literal">true</span>,</span><br><span class="line">  target: <span class="string">"prev"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾名思义，<code>can_back</code>用于 App 询问 JS：在返回上一级界面前，是否弹窗提示用户？</p><p>返回值中的<code>can</code>如果是<code>true</code>，则直接返回，不提示；如果是<code>false</code>，则弹出一个确认框，请用户确认。另一个值<code>target</code>是与 App 约定的返回目标，比如<code>prev</code>表示返回上一级，<code>top</code>表示返回顶级，等等。</p><h2 id="双向调用"><a href="#双向调用" class="headerlink" title="双向调用"></a>双向调用</h2><hr><p>双向调用是 JS 先调用 App，然后 App 在完成操作后再调用 JS，双向通常都需要传递数据。双向调用主要涉及 JS 调用 App 原生组件和用户点击右上角按钮，可对应如下<code>action</code>：</p><ul><li><code>loadComponent</code>：调用原生组件</li><li><code>displayNextButton</code>：显示 “下一步”“保存” 或“完成”按钮</li></ul><p><code>loadComponent</code>的参考协议如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NativeBridge.callNative(&#123;</span><br><span class="line">  action: <span class="string">'loadComponent'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">'location'</span>,</span><br><span class="line">    value,</span><br><span class="line">    callbackName: <span class="string">'set_location'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  whoCare: <span class="number">0</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在这个例子中，涉及 JS 调用 App 显示其实现的城市选择组件：<code>type: &#39;location&#39;</code>，用户选择完城市之后，App 再调用<code>set_location</code>，将用户选择的城市名称传给 JS：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JSBridge.callJS(&#123;</span><br><span class="line">  action: <span class="string">'set_location'</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    value: <span class="string">'北京市朝阳区'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  whoAmI: <span class="number">1</span>/<span class="number">2</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>JS 根据拿到的值更新界面，完成一次双向调用。另一个例子是 JS 调用原生的日期选择组件，与此类似。</p><p>为什么叫<code>displayNextButton</code>？因为根据具体业务场景，可能存在如下三种情况：</p><ol><li>当前 WebView 不需要显示右上角按钮，比如详情页；</li><li>当前 WebView 需要显示 “下一步” 或“保存”按钮，但需要禁用变灰；</li><li>当前 WebView 需要显示 “下一步” 或“保存”按钮，允许用户点击。</li></ol><p><code>displayNextButton</code>协议的参考实现如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">NativeBridge.callNative(&#123;</span><br><span class="line">  action: &quot;displayNextButton&quot;,</span><br><span class="line">  params: &#123;</span><br><span class="line">    name: &quot;下一步&quot;,</span><br><span class="line">    enable: false,</span><br><span class="line">    callbackName: &quot;save_form&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  whoCare: 0</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上代码示例表明，JS 调用 App，告诉 App 显示 “下一步” 按钮，但是要禁用变灰，因为<code>enable: false</code>。如果传递的是<code>enable: true</code>，那么用户就可以点击 “下一步” 按钮了。点击之后，App 再调用 JS 的<code>save_form</code>。最后，如果不想显示按钮，可以传递<code>name: &#39;&#39;</code>。</p><p>下面重点说一下用户点击 “下一步” 按钮，App 调用<code>save_form</code>的场景。此时也分两种情况：</p><ol><li>JS 直接保存数据</li><li>JS 通过 App 保存数据</li></ol><p>如果是 JS 通过 App 保存数据——可能因为 App 端实现了数据写入必需的加密机制——那么，JS 可以在 App 调用<code>save_form</code>时将约定好的数据返回给 App，由 App 去保存数据。</p><p>如果是 JS 直接保存数据，比如通过 Ajax，那么在保存完数据之后，则还需要调用前面所说的 App 暴露的<code>loadUrl</code>或<code>loadComponent</code>方法，以告知 App 切换界面。当然这种情况下会出现第三次调用，但仍然属于双向调用。</p><ol><li>哪方主导</li></ol><hr><p>本文介绍了 JS 与 App 交互的几种模式，而且只讨论了 JS 端的实现。在开发实践中，团队各端总会面临哪一端主导的问题。本文展示的参考实现就是 H5 端主导的一种实现形式。H5 主导的特点是把主要业务逻辑都封装到 WebView 中，App 主要协同配合，而优点是业务逻辑的变更不会蔓延到 App。毕竟相对于 H5，App 的安装部署模式会造成多版本共存问题，需要尽可能控制新版本。假如由 App 端主导，将逻辑封装在 App 端，势必造成版本不受控，给整个项目或产品埋下隐患。</p><p>当然，事无绝对。具体情况还要具体分析。而且，哪方主导有时候也取决多方面因素。实践中还是要因人、因时、因势制宜。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="h5" scheme="http://huangkun.host/categories/h5/"/>
    
    
      <category term="h5" scheme="http://huangkun.host/tags/h5/"/>
    
  </entry>
  
  <entry>
    <title>git找回错误reset的文件</title>
    <link href="http://huangkun.host/2020/04/02/20200402-git%E6%89%BE%E5%9B%9Ereset%E6%8E%89%E7%9A%84%E5%86%85%E5%AE%B9/"/>
    <id>http://huangkun.host/2020/04/02/20200402-git%E6%89%BE%E5%9B%9Ereset%E6%8E%89%E7%9A%84%E5%86%85%E5%AE%B9/</id>
    <published>2020-04-02T13:45:18.604Z</published>
    <updated>2020-04-21T04:35:32.724Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在写代码时，写了很久的代码，<code>git add</code> 后，发现有一点东西还要改，想退回来加上后一起提交，就脑抽执行了一下 <code>git reset --hard</code>，然后就 @#$%^*&amp;…了</p><p>这时候就去 网上找有没有补救方案，后来还真找到了</p><h2 id="可以分为3种情况"><a href="#可以分为3种情况" class="headerlink" title="可以分为3种情况"></a>可以分为3种情况</h2><ol><li><p><code>git add</code> 过, 也 <code>git commit</code> 过</p><p>可以使用 <code>git reflog</code> 找到对应的 <code>commit</code>，然后回退到对应的 <code>commit id</code></p></li><li><p><code>git add</code> 过，没有 <code>git commit</code> 过</p><p>可以用以下方法恢复，先执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fsck —lost-found</span><br></pre></td></tr></table></figure><p>然后进入到项目中的 .git/lost-found/other 目录下</p><p>该目录下的文件用 <code>vscode</code> 或其他代码编辑器打开就可以看到你 <code>git add</code> 过后的文件的长相啦</p><p>然后将对应的文件覆盖掉之前没改动之前的文件就行了</p></li><li><p>没 <code>git add</code> 过，也没有 <code>git commit</code> 过</p><p>那我就只能祝你好运了，阿门</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="git" scheme="http://huangkun.host/categories/git/"/>
    
    
      <category term="git" scheme="http://huangkun.host/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>vue刷新当前页面</title>
    <link href="http://huangkun.host/2020/03/27/20200327-vue%E5%88%B7%E6%96%B0%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2/"/>
    <id>http://huangkun.host/2020/03/27/20200327-vue%E5%88%B7%E6%96%B0%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2/</id>
    <published>2020-03-27T07:35:55.292Z</published>
    <updated>2020-03-27T07:45:12.811Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>在 <code>vue</code> 写的后台管理项目中，经常会有增、删、改、查的操作，这些操作只是跟用接口跟后台交互下，既然用接口交互，那肯定就是 <code>axios</code> 的异步请求，那么就是说后台数据发生了改变，但是前台的数据并没有实时的更新（每次操作完后台把列表数据重新返给你例外，但是这样的话每次交互的数据量就偏大了），所以就有了动态路由。在使用动态路由配置 <code>/detail/:id</code> 这样的情况下，由于 <code>router-view</code> 是复用的，单纯的改变id的值并不会刷新 <code>router-view</code> 所以就要想一个办法，让后台执行完操作后，给前台返一个操作结果，然后前台手动刷新页面，一开始我想到的是用 <code>window.location.reload()</code> 或者 <code>this.$router.go(0)</code> 这两个方法，但是后来发现这两个方法消耗都很大，用户体验并不太好，违背了 <code>vue-router</code> 的初衷，所以就放弃了，看了下别人的做法，整理下面两种方法：</p><h2 id="第一种：中转站的方式"><a href="#第一种：中转站的方式" class="headerlink" title="第一种：中转站的方式"></a>第一种：中转站的方式</h2><p>用一个空白组件在每次操作之后进行跳转，相当于<code>Nginx</code>的反向代理一样。意思就是让每次操作完成以后，都让路由跳转到这个中转站页面，然后这个页面获取到进来路由的路径再返回去就可以了。这种方式如果说你的路由是显性的，就是直接显示在浏览器地址栏，你会发现，一直在换，而我目前使用的则是第二种方式。</p><h2 id="第二种：provide-inject-的方式"><a href="#第二种：provide-inject-的方式" class="headerlink" title="第二种：provide / inject 的方式"></a>第二种：provide / inject 的方式</h2><p>通过 <code>provide</code> 让 <code>App.vue</code> 为所有子组件注入一个 <code>reload</code> 方法，然后在需要使用的页面，通过 <code>inject</code> 注入即可、请看代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span> <span class="attr">v-if</span>=<span class="string">"isRouterAlive"</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">  name: <span class="string">"App"</span>,</span></span><br><span class="line">  provide() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      reload: <span class="keyword">this</span>.reload</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="actionscript">      isRouterAlive: <span class="literal">true</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    reload() &#123;</span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.isRouterAlive = <span class="literal">false</span>;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">this</span>.isRouterAlive = <span class="literal">true</span>;</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在需要调用的子页面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--你的子页面布局--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="actionscript">    <span class="comment">//...</span></span></span><br><span class="line"><span class="actionscript">    inject: [<span class="string">'reload'</span>],</span></span><br><span class="line">    methods: &#123;</span><br><span class="line">        delData()&#123;</span><br><span class="line"><span class="actionscript">            <span class="comment">//在axios成功的回调里面</span></span></span><br><span class="line"><span class="actionscript">            <span class="keyword">this</span>.reload();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    <span class="comment">//...</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="vue" scheme="http://huangkun.host/categories/vue/"/>
    
    
      <category term="vue" scheme="http://huangkun.host/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>前端基础面试题</title>
    <link href="http://huangkun.host/2020/03/25/20200325-%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://huangkun.host/2020/03/25/20200325-%E5%89%8D%E7%AB%AF%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-03-25T08:51:09.013Z</published>
    <updated>2020-03-25T08:52:03.175Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这里有一道前端基础面试题</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">1</span>) &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">2</span>) &#125;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">3</span>) &#125;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; alert (<span class="number">4</span>) &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; alert (<span class="number">5</span>) &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//请写出以下输出结果：</span></span><br><span class="line">Foo.getName();                  <span class="comment">// =&gt; 2</span></span><br><span class="line">getName();                      <span class="comment">// =&gt; 4</span></span><br><span class="line">Foo().getName();                <span class="comment">// =&gt; 1</span></span><br><span class="line">getName();                      <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName();              <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName();            <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();        <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure><p>大家尝试着先不要看右边注释的答案, 看下自己做的答案跟正确答案是否相同, 如果全部答对了, 就代表这些知识点你都掌握了, 可以不用往下看了</p><hr /><h1 id="第一问"><a href="#第一问" class="headerlink" title="第一问"></a>第一问</h1><p>第一问的Foo.getName自然是访问Foo函数上存储的静态属性，答案自然是2，这里就不需要解释太多的，一般来说第一问对于稍微懂JS基础的同学来说应该是没问题的,当然我们可以用下面的代码来回顾一下基础，先加深一下了解</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = name; <span class="comment">//私有属性</span></span><br><span class="line">  <span class="keyword">this</span>.name = name; <span class="comment">//公有属性</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="comment">//私有方法</span></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//公有方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">Person.name = <span class="string">'Foo'</span>; <span class="comment">//静态属性</span></span><br><span class="line">Person.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//静态方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Person(<span class="string">'Foo'</span>); <span class="comment">//实例化</span></span><br></pre></td></tr></table></figure><blockquote><p>注意下面这几点：</p></blockquote><ul><li><p>调用公有方法，公有属性，我们必需先实例化对象，也就是用new操作符实化对象，就可构造函数实例化对象的方法和属性，并且公有方法是不能调用私有方法和静态方法的</p></li><li><p>静态方法和静态属性就是我们无需实例化就可以调用</p></li><li><p>而对象的私有方法和属性,外部是不可以访问的</p></li></ul><hr /><h1 id="第二问"><a href="#第二问" class="headerlink" title="第二问"></a>第二问</h1><p>直接调用 <code>getName</code> 函数。既然是直接调用那么就是访问当前上文作用域内的叫 <code>getName</code> 的函数，此处其实有两个坑，一是变量声明提升，二是函数表达式和函数声明的区别。</p><p>我们来看看为什么，可参考(1)关于Javascript的函数声明和函数表达式 (2)关于JavaScript的变量提升</p><p>在Javascript中，定义函数有两种类型</p><h2 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> type === <span class="string">'foo'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> type === <span class="string">'foo'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，先来看一个 在一个程序里面同时用函数声明和函数表达式定义一个名为 <code>getName</code> 的函数 的题目</p><p>三次 <code>getName()</code> 分别打印什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">getName() <span class="comment">// bar</span></span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line">getName() <span class="comment">// foo</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">&#125;</span><br><span class="line">getName() <span class="comment">// foo</span></span><br></pre></td></tr></table></figure><ul><li><p><strong>JavaScript 解释器中存在一种变量声明被提升的机制，也就是说函数声明会被提升到作用域的最前面，即使写代码的时候是写在最后面，也还是会被提升至最前面</strong>。</p></li><li><p><strong>而用函数表达式创建的函数是在运行时进行赋值，且要等到表达式赋值完成后才能调用</strong></p></li></ul><p>也许这样解释了还不是很清楚, 其实可以把上面的问题等同于下面的写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 函数声明的提升, 原来第6行的函数getName声明提升到这里了</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> getName <span class="comment">// 变量声明的提升, 原来第2行的变量getName声明提升到这里了</span></span><br><span class="line">getName()</span><br><span class="line">getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">&#125;</span><br><span class="line">getName()</span><br><span class="line">getName()</span><br></pre></td></tr></table></figure><p>为什么会两种写法会等同呢，因为 <code>JavaScript</code> 解释器会对 <strong>函数声明</strong>和<strong>变量声明</strong>进行提升, 且<strong>函数声明</strong>的提升优于<strong>变量声明</strong>的提升</p><blockquote><p>注意: 变量的声明会提升 而 变量的赋值是不会提升的!!!</p></blockquote><p>那么现在再来看原题就可以得出答案4了, 而不是5</p><hr /><h1 id="第三问"><a href="#第三问" class="headerlink" title="第三问"></a>第三问</h1><p><code>Foo().getName()</code> 先执行了 <code>Foo</code> 函数，然后调用 <code>Foo</code> 函数的返回值对象的 <code>getName</code> 属性函数。</p><p><code>Foo</code> 函数的第一句 <code>getName = function() { alert (1) }</code> 是一句函数赋值语句，注意它没有 <code>var</code> 声明，所以先向当前 <code>Foo</code> 函数作用域内寻找 <code>getName</code> 变量，没有。再向当前函数作用域上层，即外层作用域内寻找是否含有 <code>getName</code> 变量，找到了，也就是第二问中的 <code>alert(4)</code> 函数，将此变量的值赋值为 <code>function() { alert(1) }</code>。</p><p>此处实际上是将外层作用域内的 <code>getName</code> 函数修改了。</p><blockquote><p>注意：此处若依然没有找到会一直向上查找到 <code>window</code> 对象，若 <code>window</code> 对象中也没有 <code>getName</code> 属性，就在 <code>window</code> 对象中创建一个 <code>getName</code> 变量。</p></blockquote><p>之后 <code>Foo</code> 函数的返回值是 <code>this</code>，而 JS 的 <code>this</code> 问题已经有非常多的文章介绍，这里不再多说，而此处的直接调用方式，<code>this</code>指向 <code>window</code> 对象。</p><p>遂 <code>Foo</code> 函数返回的是 <code>window</code> 对象，相当于执行 <code>window.getName()</code>，而 <code>window</code> 中的 <code>getName</code> 已经被修改为 <code>alert(1)</code>，所以最终会输出1</p><p>此处考察了两个知识点，一个是变量作用域问题，一个是<code>this</code>指向问题</p><hr /><h1 id="第四问"><a href="#第四问" class="headerlink" title="第四问"></a>第四问</h1><p>直接调用 <code>getName</code> 函数，相当于 <code>window.getName()</code>，因为这个变量已经被 <code>Foo</code> 函数执行时修改了，遂结果与第三问相同，为1，也就是说 <code>Foo</code> 执行后把全局的 <code>getName</code> 函数给重写了一次，所以结果就是 <code>Foo()</code> 执行重写的那个 <code>getName</code> 函数</p><hr /><h1 id="第五问"><a href="#第五问" class="headerlink" title="第五问"></a>第五问</h1><p><code>new Foo.getName()</code>，此处考察的是JS的运算符优先级问题</p><p>下面是JS运算符的优先级表格，从高到低排列。可参考MDN运算符优先级</p><table><thead><tr><th>优先级</th><th>运算类型</th><th>关联性</th><th>运算符</th></tr></thead><tbody><tr><td>19</td><td>圆括号</td><td>n/a</td><td>( … )</td></tr><tr><td>18</td><td>成员访问</td><td>从左到右</td><td>… . …</td></tr><tr><td></td><td>需计算的成员访问</td><td>从左到右</td><td>… [ … ]</td></tr><tr><td></td><td>new (带参数列表)</td><td>n/a</td><td>new    … ( … )</td></tr><tr><td>17</td><td>函数调用</td><td>从左到右</td><td>… ( … )</td></tr><tr><td></td><td>new (无参数列表)</td><td>从右到左</td><td>new …</td></tr><tr><td>16</td><td>后置递增</td><td>(运算符在后)    n/a</td><td>… ++</td></tr><tr><td></td><td>后置递减(运算符在后)</td><td>n/a</td><td>… –</td></tr><tr><td>15</td><td>逻辑非</td><td>从右到左</td><td>! …</td></tr><tr><td></td><td>按位非</td><td>从右到左</td><td>~ …</td></tr><tr><td></td><td>一元加法</td><td>从右到左</td><td>+ …</td></tr><tr><td></td><td>一元减法</td><td>从右到左</td><td>- …</td></tr><tr><td></td><td>前置递增</td><td>从右到左</td><td>++ …</td></tr><tr><td></td><td>前置递减</td><td>从右到左</td><td>– …</td></tr><tr><td></td><td>typeof</td><td>从右到左</td><td>typeof …</td></tr><tr><td></td><td>void</td><td>从右到左</td><td>void …</td></tr><tr><td></td><td>delete</td><td>从右到左</td><td>delete …</td></tr><tr><td>14</td><td>乘法</td><td>从左到右</td><td>… * …</td></tr><tr><td></td><td>除法</td><td>从左到右</td><td>… / …</td></tr><tr><td></td><td>取模</td><td>从左到右</td><td>… % …</td></tr><tr><td>13</td><td>加法</td><td>从左到右</td><td>… + …</td></tr><tr><td></td><td>减法</td><td>从左到右</td><td>… - …</td></tr><tr><td>12</td><td>按位左移</td><td>从左到右</td><td>… &lt;&lt; …</td></tr><tr><td></td><td>按位右移</td><td>从左到右</td><td>… &gt;&gt; …</td></tr><tr><td></td><td>无符号右移</td><td>从左到右</td><td>… &gt;&gt;&gt; …</td></tr><tr><td>11</td><td>小于</td><td>从左到右</td><td>… &lt; …</td></tr><tr><td></td><td>小于等于</td><td>从左到右</td><td>… &lt;= …</td></tr><tr><td></td><td>大于</td><td>从左到右</td><td>… &gt; …</td></tr><tr><td></td><td>大于等于</td><td>从左到右</td><td>… &gt;= …</td></tr><tr><td></td><td>in</td><td>从左到右</td><td>… in …</td></tr><tr><td></td><td>instanceof</td><td>从左到右</td><td>… instanceof …</td></tr><tr><td>10</td><td>等号</td><td>从左到右</td><td>… == …</td></tr><tr><td></td><td>非等号</td><td>从左到右</td><td>… != …</td></tr><tr><td></td><td>全等号</td><td>从左到右</td><td>… === …</td></tr><tr><td></td><td>非全等号</td><td>从左到右</td><td>… !== …</td></tr><tr><td>9</td><td>按位与</td><td>从左到右</td><td>… &amp; …</td></tr><tr><td>8</td><td>按位异或</td><td>从左到右</td><td>… ^ …</td></tr><tr><td>7</td><td>按位或</td><td>从左到右</td><td>… 按位或 …</td></tr><tr><td>6</td><td>逻辑与</td><td>从左到右</td><td>… &amp;&amp; …</td></tr><tr><td>5</td><td>逻辑或</td><td>从左到右</td><td>… 逻辑或 …</td></tr><tr><td>4</td><td>条件运算符</td><td>从右到左</td><td>… ? … : …</td></tr><tr><td>3</td><td>赋值</td><td>从右到左</td><td>… = …</td></tr><tr><td></td><td></td><td></td><td>… += …</td></tr><tr><td></td><td></td><td></td><td>… -= …</td></tr><tr><td></td><td></td><td></td><td>… *= …</td></tr><tr><td></td><td></td><td></td><td>… /= …</td></tr><tr><td></td><td></td><td></td><td>… %= …</td></tr><tr><td></td><td></td><td></td><td>… &lt;&lt;= …</td></tr><tr><td></td><td></td><td></td><td>… &gt;&gt;= …</td></tr><tr><td></td><td></td><td></td><td>… &gt;&gt;&gt;= …</td></tr><tr><td></td><td></td><td></td><td>… &amp;= …</td></tr><tr><td></td><td></td><td></td><td>… ^= …</td></tr><tr><td></td><td></td><td></td><td>… 或= …</td></tr><tr><td>2</td><td>yield</td><td>从右到左</td><td>yield …</td></tr><tr><td></td><td>yield*</td><td>从右到左</td><td>yield* …</td></tr><tr><td>1</td><td>展开运算符</td><td>n/a</td><td>… …</td></tr><tr><td>0</td><td>逗号</td><td>从左到右</td><td>… , …</td></tr></tbody></table><p><code>new Foo.getName()</code> 的优先级是这样的，相当于是：<code>new (Foo.getName)()</code></p><p>所以这里实际上将 <code>getName</code> 函数作为了构造函数来执行，遂弹出2。</p><hr /><h1 id="第六问"><a href="#第六问" class="headerlink" title="第六问"></a>第六问</h1><p>这一题比上一题的唯一区别就是在Foo那里多出了一个括号，这个有括号跟没括号我们在第五问的时候也看出来优先级是有区别的</p><p><code>(new Foo()).getName()</code></p><p>这里还有一个小知识点，Foo作为构造函数有返回值，所以这里需要说明下JS中的构造函数返回值问题。</p><h2 id="构造函数的返回值"><a href="#构造函数的返回值" class="headerlink" title="构造函数的返回值"></a>构造函数的返回值</h2><p>在传统语言中，构造函数不应该有返回值，实际执行的返回值就是此构造函数的实例化对象。<br>而在JS中构造函数可以有返回值也可以没有。</p><p>没有返回值则按照其他语言一样返回实例化对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Foo(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure><p>若有返回值则检查其返回值是否为引用类型。如果是非引用类型，如基本类型（String,Number,Boolean,Null,Undefined）则与无返回值相同，实际返回其实例化对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">return</span> <span class="number">520</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Foo(<span class="string">'foo'</span>)) <span class="comment">// 还是返回实例化对象</span></span><br></pre></td></tr></table></figure><p>若返回值是引用类型，则实际返回值为这个引用类型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    age: <span class="number">16</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">new</span> Foo(<span class="string">'foo'</span>)) <span class="comment">// 返回 &#123;age: 16&#125;</span></span><br></pre></td></tr></table></figure><p>原题中，由于返回的是 <code>this</code>，而 <code>this</code> 在构造函数中本来就代表当前实例化对象，最终 Foo 函数返回实例化对象。</p><p>之后调用实例化对象的 <code>getName</code> 函数，因为在 <code>Foo</code> 构造函数中没有为实例化对象添加任何属性，当前对象的原型对象 <code>prototype</code> 中寻找 <code>getName</code> 函数。</p><blockquote><p>这里再拓展个题外话，如果构造函数和原型链都有相同的方法，那么默认会拿构造函数的公有方法而不是原型链</p></blockquote><hr /><h1 id="第七问"><a href="#第七问" class="headerlink" title="第七问"></a>第七问</h1><p><code>new new Foo().getName()</code> 同样是运算符优先级问题。做到这一题其实我已经觉得答案没那么重要了，关键只是考察面试者是否真的知道面试官在考察我们什么。<br>最终实际执行为:</p><p><code>new ((new Foo()).getName)()</code></p><p>先初始化Foo的实例化对象，然后将其原型上的getName函数作为构造函数再次new，所以最终结果为3</p><hr /><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>我们再来把原题的难读加大一点</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      getName: getName <span class="comment">//这个就是第六问中涉及的构造函数的返回值问题</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;; <span class="comment">//这个就是第六问中涉及到的，JS构造函数公有方法和原型链方法的优先级</span></span><br><span class="line">  getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">Foo.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;;</span><br><span class="line">Foo.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">6</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//答案：</span></span><br><span class="line">Foo.getName();                  <span class="comment">// =&gt; 2</span></span><br><span class="line">getName();                      <span class="comment">// =&gt; 4</span></span><br><span class="line"><span class="built_in">console</span>.log(Foo())              <span class="comment">// =&gt; window</span></span><br><span class="line">Foo().getName();                <span class="comment">// =&gt; 1</span></span><br><span class="line">getName();                      <span class="comment">// =&gt; 1</span></span><br><span class="line"><span class="keyword">new</span> Foo.getName();              <span class="comment">// =&gt; 2</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName();            <span class="comment">// =&gt; 3</span></span><br><span class="line"><span class="keyword">new</span> Foo().getName().getName();  <span class="comment">// =&gt; 3 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">new</span> Foo().getName();        <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="interview" scheme="http://huangkun.host/categories/interview/"/>
    
    
      <category term="interview" scheme="http://huangkun.host/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>macOS改变文件的创建时间</title>
    <link href="http://huangkun.host/2020/03/25/20200324-macOS%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4/"/>
    <id>http://huangkun.host/2020/03/25/20200324-macOS%E6%94%B9%E5%8F%98%E6%96%87%E4%BB%B6%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E9%97%B4/</id>
    <published>2020-03-25T07:36:28.432Z</published>
    <updated>2020-04-13T05:53:35.896Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p><code>Vue.use</code> 其实就是一个 <code>Vue</code> 提供的全局 <code>api</code> , 我们在做项目的时候经常遇到要用一些不管是官方推荐的或者是第三方的插件, 例如 <code>Vue-Router</code>, <code>Vuex</code>, <code>Element-UI</code> 等等</p><p>这些第三方库和插件一般都是在项目的 <code>main.js</code> 文件中进行初始化, 且初始化的方法就是使用 <code>Vue.use(插件名)</code></p><p>我们先来从使用到分析 <code>Vue.use</code> 是怎么实现的</p><hr><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h3 id="Vue-use-plugin-arguments"><a href="#Vue-use-plugin-arguments" class="headerlink" title="Vue.use(plugin, arguments)"></a>Vue.use(plugin, arguments)</h3><ul><li><p>参数:</p><p><code>{Object | Function} plugin</code></p></li><li><p>用法:</p><p>安装 <code>Vue.js</code> 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 <code>install</code> 方法。<code>install</code> 方法调用时，会将 Vue 作为参数传入。</p><p>该方法需要在调用 <code>new Vue()</code> 之前被调用。</p><p>当 <code>install</code> 方法被同一个插件多次调用，插件将只会被安装一次</p></li><li><p>参考 <a href="https://cn.vuejs.org/v2/guide/plugins.html" target="_blank" rel="noopener">插件</a></p></li></ul><hr><h1 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h1><p>首先新建两个文件</p><p><code>plugin.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件: src/plugins.js</span></span><br><span class="line"><span class="keyword">const</span> Plugin1 = &#123;</span><br><span class="line">  install(a, b, c) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Plugin1 第一个参数:'</span>, a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Plugin1 第二个参数:'</span>, b);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Plugin1 第三个参数:'</span>, c);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin2</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Plugin2 第一个参数:'</span>, a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Plugin2 第二个参数:'</span>, b);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Plugin2 第三个参数:'</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> &#123; Plugin1, Plugin2 &#125;;</span><br></pre></td></tr></table></figure><p><code>index.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件: src/use/index.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; Plugin1, Plugin2 &#125; <span class="keyword">from</span> <span class="string">'./plugins'</span>;</span><br><span class="line"> </span><br><span class="line">Vue.use(Plugin1, <span class="string">'参数1'</span>, <span class="string">'参数2'</span>);</span><br><span class="line">Vue.use(Plugin2, <span class="string">'参数A'</span>, <span class="string">'参数B'</span>);</span><br></pre></td></tr></table></figure><p>然后在入口文件 <code>main.js</code> 里面引入 <code>index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件: src/main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">'@/use'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"> </span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时我们执行 <code>npm run dev</code> 打开 <code>8080</code> 端口开启开发调试工具可以看到控制台输出以下信息</p><p>从中可以发现我们在 <code>plugin1</code> 中的 <code>install</code> 方法编写的三个 <code>console</code> 都打印出来，第一个打印出来的是 <code>Vue</code> 对象，第二个跟第三个是我们传入的两个参数。</p><p>而 <code>plugin2</code> 没有 <code>install</code> 方法，它本身就是一个方法，也能打印三个参数，第一个是 <code>Vue</code> 对象，第二个跟第三个也是我们传入的两个参数。</p><hr><h1 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue源码文件路径：src/core/global-api/use.js</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: Function | Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> installedPlugins = (<span class="keyword">this</span>._installedPlugins || (<span class="keyword">this</span>._installedPlugins = []))</span><br><span class="line">    <span class="comment">// 判断次插件是否已经被注册过, 如果注册过, 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// additional parameters</span></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    args.unshift(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中我们可以发现 <code>Vue</code> 首先判断这个插件是否被注册过，不允许重复注册。</p><p>并且接收的 <code>plugin</code> 参数的限制是 <code>Function | Object</code> 两种类型。</p><p>对于这两种类型有不同的处理。</p><p>首先将我们传入的参数整理成数组 =&gt; <code>const args = toArray(arguments, 1)</code>。</p><p>再将 <code>Vue</code> 对象添加到这个数组的起始位置 args.unshift(this) ,这里的this 指向 <code>Vue</code> 对象</p><p>如果我们传入的 <code>plugin(Vue.use的第一个参数)</code> 的 <code>install</code> 是一个方法。也就是说如果我们传入一个对象，对象中包含 <code>install</code> 方法，那么我们就调用这个 <code>plugin</code> 的 <code>install</code> 方法并将整理好的数组当成参数传入 <code>install</code> 方法中。 =&gt; <code>plugin.install.apply(plugin, args)</code></p><p>如果我们传入的 <code>plugin</code> 就是一个函数,那么我们就直接调用这个函数并将整理好的数组当成参数传入。 =&gt; <code>plugin.apply(null, args)</code></p><p>之后给这个插件添加至已经添加过的插件数组中，标示已经注册过 =&gt; <code>installedPlugins.push(plugin)</code></p><p>最后返回 <code>Vue</code> 对象。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过以上分析我们可以知道，在我们以后编写插件的时候可以有两种方式。</p><p>一种是将这个插件的逻辑封装成一个对象最后将最后在 <code>install</code> 编写业务代码暴露给Vue对象。这样做的好处是可以添加任意参数在这个对象上方便将 <code>install</code> 函数封装得更加精简，可拓展性也比较高。</p><p>还有一种则是将所有逻辑都编写成一个函数暴露给 <code>Vue</code></p><p>其实两种方法原理都一样，无非第二种就是将这个插件直接当成 <code>install</code> 函数来处理。</p><blockquote><p>个人推荐第一种。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="vue" scheme="http://huangkun.host/categories/vue/"/>
    
    
      <category term="vue" scheme="http://huangkun.host/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue.use源码分析</title>
    <link href="http://huangkun.host/2020/03/25/20200210-vue.use-source-code/"/>
    <id>http://huangkun.host/2020/03/25/20200210-vue.use-source-code/</id>
    <published>2020-03-25T07:36:28.431Z</published>
    <updated>2020-03-25T08:15:12.185Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h1><p><code>Vue.use</code> 其实就是一个 <code>Vue</code> 提供的全局 <code>api</code> , 我们在做项目的时候经常遇到要用一些不管是官方推荐的或者是第三方的插件, 例如 <code>Vue-Router</code>, <code>Vuex</code>, <code>Element-UI</code> 等等</p><p>这些第三方库和插件一般都是在项目的 <code>main.js</code> 文件中进行初始化, 且初始化的方法就是使用 <code>Vue.use(插件名)</code></p><p>我们先来从使用到分析 <code>Vue.use</code> 是怎么实现的</p><hr><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h3 id="Vue-use-plugin-arguments"><a href="#Vue-use-plugin-arguments" class="headerlink" title="Vue.use(plugin, arguments)"></a>Vue.use(plugin, arguments)</h3><ul><li><p>参数:</p><p><code>{Object | Function} plugin</code></p></li><li><p>用法:</p><p>安装 <code>Vue.js</code> 插件。如果插件是一个对象，必须提供 <code>install</code> 方法。如果插件是一个函数，它会被作为 <code>install</code> 方法。<code>install</code> 方法调用时，会将 Vue 作为参数传入。</p><p>该方法需要在调用 <code>new Vue()</code> 之前被调用。</p><p>当 <code>install</code> 方法被同一个插件多次调用，插件将只会被安装一次</p></li><li><p>参考 <a href="https://cn.vuejs.org/v2/guide/plugins.html" target="_blank" rel="noopener">插件</a></p></li></ul><hr><h1 id="举个🌰"><a href="#举个🌰" class="headerlink" title="举个🌰"></a>举个🌰</h1><p>首先新建两个文件</p><p><code>plugin.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件: src/plugins.js</span></span><br><span class="line"><span class="keyword">const</span> Plugin1 = &#123;</span><br><span class="line">  install(a, b, c) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Plugin1 第一个参数:'</span>, a);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Plugin1 第二个参数:'</span>, b);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Plugin1 第三个参数:'</span>, c);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Plugin2</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Plugin2 第一个参数:'</span>, a);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Plugin2 第二个参数:'</span>, b);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Plugin2 第三个参数:'</span>, c);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> &#123; Plugin1, Plugin2 &#125;;</span><br></pre></td></tr></table></figure><p><code>index.js</code>:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件: src/use/index.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; Plugin1, Plugin2 &#125; <span class="keyword">from</span> <span class="string">'./plugins'</span>;</span><br><span class="line"> </span><br><span class="line">Vue.use(Plugin1, <span class="string">'参数1'</span>, <span class="string">'参数2'</span>);</span><br><span class="line">Vue.use(Plugin2, <span class="string">'参数A'</span>, <span class="string">'参数B'</span>);</span><br></pre></td></tr></table></figure><p>然后在入口文件 <code>main.js</code> 里面引入 <code>index.js</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件: src/main.js</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> <span class="string">'@/use'</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'./App'</span>;</span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">'./router'</span>;</span><br><span class="line"> </span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* eslint-disable no-new */</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App),</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>此时我们执行 <code>npm run dev</code> 打开 <code>8080</code> 端口开启开发调试工具可以看到控制台输出以下信息</p><p>从中可以发现我们在 <code>plugin1</code> 中的 <code>install</code> 方法编写的三个 <code>console</code> 都打印出来，第一个打印出来的是 <code>Vue</code> 对象，第二个跟第三个是我们传入的两个参数。</p><p>而 <code>plugin2</code> 没有 <code>install</code> 方法，它本身就是一个方法，也能打印三个参数，第一个是 <code>Vue</code> 对象，第二个跟第三个也是我们传入的两个参数。</p><hr><h1 id="分析源码"><a href="#分析源码" class="headerlink" title="分析源码"></a>分析源码</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue源码文件路径：src/core/global-api/use.js</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> &#123; toArray &#125; <span class="keyword">from</span> <span class="string">'../util/index'</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initUse</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  Vue.use = <span class="function"><span class="keyword">function</span> (<span class="params">plugin: Function | Object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> installedPlugins = (<span class="keyword">this</span>._installedPlugins || (<span class="keyword">this</span>._installedPlugins = []))</span><br><span class="line">    <span class="comment">// 判断次插件是否已经被注册过, 如果注册过, 直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (installedPlugins.indexOf(plugin) &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// additional parameters</span></span><br><span class="line">    <span class="keyword">const</span> args = toArray(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">    args.unshift(<span class="keyword">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin.install === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.install.apply(plugin, args)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> plugin === <span class="string">'function'</span>) &#123;</span><br><span class="line">      plugin.apply(<span class="literal">null</span>, args)</span><br><span class="line">    &#125;</span><br><span class="line">    installedPlugins.push(plugin)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中我们可以发现 <code>Vue</code> 首先判断这个插件是否被注册过，不允许重复注册。</p><p>并且接收的 <code>plugin</code> 参数的限制是 <code>Function | Object</code> 两种类型。</p><p>对于这两种类型有不同的处理。</p><p>首先将我们传入的参数整理成数组 =&gt; <code>const args = toArray(arguments, 1)</code>。</p><p>再将 <code>Vue</code> 对象添加到这个数组的起始位置 args.unshift(this) ,这里的this 指向 <code>Vue</code> 对象</p><p>如果我们传入的 <code>plugin(Vue.use的第一个参数)</code> 的 <code>install</code> 是一个方法。也就是说如果我们传入一个对象，对象中包含 <code>install</code> 方法，那么我们就调用这个 <code>plugin</code> 的 <code>install</code> 方法并将整理好的数组当成参数传入 <code>install</code> 方法中。 =&gt; <code>plugin.install.apply(plugin, args)</code></p><p>如果我们传入的 <code>plugin</code> 就是一个函数,那么我们就直接调用这个函数并将整理好的数组当成参数传入。 =&gt; <code>plugin.apply(null, args)</code></p><p>之后给这个插件添加至已经添加过的插件数组中，标示已经注册过 =&gt; <code>installedPlugins.push(plugin)</code></p><p>最后返回 <code>Vue</code> 对象。</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>通过以上分析我们可以知道，在我们以后编写插件的时候可以有两种方式。</p><p>一种是将这个插件的逻辑封装成一个对象最后将最后在 <code>install</code> 编写业务代码暴露给Vue对象。这样做的好处是可以添加任意参数在这个对象上方便将 <code>install</code> 函数封装得更加精简，可拓展性也比较高。</p><p>还有一种则是将所有逻辑都编写成一个函数暴露给 <code>Vue</code></p><p>其实两种方法原理都一样，无非第二种就是将这个插件直接当成 <code>install</code> 函数来处理。</p><blockquote><p>个人推荐第一种。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="vue" scheme="http://huangkun.host/categories/vue/"/>
    
    
      <category term="vue" scheme="http://huangkun.host/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>image访问图片跨域的问题</title>
    <link href="http://huangkun.host/2020/03/25/20191212-image%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%89%87%E8%B7%A8%E5%9F%9F%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://huangkun.host/2020/03/25/20191212-image%E8%AE%BF%E9%97%AE%E5%9B%BE%E7%89%87%E8%B7%A8%E5%9F%9F%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2020-03-25T07:36:28.430Z</published>
    <updated>2020-03-25T08:14:12.379Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>项目(vue项目)中遇到一个问题，有一个需求，在一个图片预览的组件中，左边是图片的缩略图，右边是一个图片的可编辑区域(用canvas画布实现的,图片的放大/缩小/旋转/移动/镜像等操作)，开发人员在开发的时候发现: 如果打开F12，则不会报跨域问题，如果关闭F12，就会报跨域问题，报错如下:</p><img style="width: 900px;" src="../../assets/images/image_error.jpg"><p>意思是在访问图片时出现了跨域问题</p><h2 id="问题梳理"><a href="#问题梳理" class="headerlink" title="问题梳理"></a>问题梳理</h2><p>这里先给出结论: 同一个图片在 dom 节点中使用了 img标签来加载，同时在其他地方用了脚本去生成一个同src 的 img 标签, 就会出现此问题</p><p>我们项目中即是这样, 又在 dom 节点中使用了 img 标签来加载， 同时在右侧canvas组件中用了脚本去生成一个 img 标签</p><h3 id="图片的加载分析"><a href="#图片的加载分析" class="headerlink" title="图片的加载分析"></a>图片的加载分析</h3><p>图片是来自于客户的问题存储服务器的，和本地 localhost 必然存在跨域问题。通过 dom 节点的 img 标签来直接访问是没有问题，因为浏览器本身不会有跨域问题。问题出在了我们自己写的一个canvas图片展示和编辑的组件中, 使用了new Image(); img.src = xxx; 来创建图片, 代码大致如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.crossOrigin = <span class="string">'anonymous'</span>;</span><br><span class="line">img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">img.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line">img.src = <span class="keyword">this</span>.imgs;</span><br></pre></td></tr></table></figure><p>这段代码所描述的大致思路是：</p><ol><li><p>通过JS代码，创建一个 img 的 dom ，然后使用这个 img 标签来加载图片。</p></li><li><p>默认情况下，设置了 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/CORS_settings_attributes" target="_blank" rel="noopener">crossOrigin</a> 的跨域属性为 ‘anonymous’。</p></li></ol><p>所以，问题的关键在于，同一张图片</p><p>① 先用 img 标签去加载了(此img标签没有设置 crossOrigin 属性为 ‘anonymous’)</p><p>② 再在 JS 代码中，创建一个 img 并且设置了 crossOrigin 的跨域属性为 ‘anonymous’，那么在 JS 中创建的 img 就会出现访问图片而产生跨域的问题。</p><h3 id="关于crossOrigin"><a href="#关于crossOrigin" class="headerlink" title="关于crossOrigin"></a>关于crossOrigin</h3><ol><li><p>加了 crossorigin 属性，则表明图片就一定会按照 CORS 来请求图片。而通过CORS 请求到的图片可以再次被复用到 canvas 上进行绘制。换言之，如果不加 crossorigin 属性的话，那么图片是不能再次被复用到 canvas 上去的。</p></li><li><p>可以设置的值有 anonymous 以及 use-credentials，2 个 value 的作用都是设置通过 CORS 来请求图片，区别在于 use-credentials 是加了证书的 CORS。</p></li><li><p>如果默认用户不进行任何设置，那么就不会发起 CORS 请求。但如果设置了除 anonymous 和 use-credentials 以外的其他值，包括空字串在内，默认会当作 anonymous来处理。</p></li></ol><h3 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h3><p>通过前面 2 点的梳理，我们得出如下结论：</p><ol><li><p>通过 ‘img’ 加载的图片，浏览器默认情况下会将其缓存起来。</p></li><li><p>当我们从 JS 的代码中创建的 ‘img’ 再去访问同一个图片时，浏览器就不会再发起新的请求，而是直接访问缓存的图片。但是由于 JS 中的 ‘img’ 设置了 crossorigin，也就意味着它将要以 CORS 的方式请求，但缓存中的图片显然不是的，所以浏览器直接就拒绝了。连网络请求都没有发起。</p></li><li><p>在 Chrome 的调试器中，在 network 面板中，我们勾选了 disable cache 选项，验证了问题确实如第 2 点所述，浏览器这时发起了请求并且 JS 的 ‘img’ 也能正常请求到图片。</p></li></ol><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>前面通过勾选 disable cache 来避免浏览器使用缓存图片而解决了问题，但实际用户不会这样使用啊。根据前面的梳理，’img’ 不跨域请求，而 JS 中的 ‘img’ 跨域请求，所以不能访问缓存，那么是不是可以将 JS 中的 ‘img’ 也设置成不跨域呢，于是将 JS 中的 ‘img’ 的 crossorigin 设置为 undefine，结果图片是可以加载了，但又报错, 错误的意思是，这一个来自于CORS 的图片，是不可以再次被复用到 canvas 上去的。这就验证了关于 crossorigin 中的第 1 点。</p><p>既然 ‘img’ 和 JS 中的 ‘img’ 都不加 crossorigin不能解决 canvas 重用的问题，那么在两边同时都加上 crossorigin 呢？果然，在 ‘img’ 中和 JS 中的 ‘img’ 都加上 crossorigin = “anonymous”，图片可以正常加了，同时也可以被复用到 ‘canvas’ 上去了。</p><p>另外，需要注意 2 个小问题是：</p><ol><li>服务器必须加上字段，否则，客户端设置了也是没用的。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure><ol start="2"><li>如果是已经出了问题，你才看到这篇文章，或者才去想到这么解决。那么要记得先清理一下游览器所缓存的图片。否则你就会发现，有的图片可以访问，而有的不可以。那是因为缓存中之前存储了未 CORS 的图片。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://huangkun.host/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://huangkun.host/tags/javascript/"/>
    
      <category term="CORS" scheme="http://huangkun.host/tags/CORS/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的js奇淫技巧</title>
    <link href="http://huangkun.host/2020/03/25/20191210-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%E6%8A%80%E5%B7%A7/"/>
    <id>http://huangkun.host/2020/03/25/20191210-%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84js%E6%8A%80%E5%B7%A7/</id>
    <published>2020-03-25T07:36:28.428Z</published>
    <updated>2020-03-25T08:21:59.869Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在js中, 有一些常用的奇淫技巧, 可以让你少写很多代码, 但是你不一定见过这种写法, 下面就记录几个js的奇淫技巧, 防止自己在以后看见的时候懵逼</p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="keyword">var</span> uniqueArr = [...new <span class="built_in">Set</span>(arr)];</span><br><span class="line"><span class="built_in">console</span>.log(uniqueArr); <span class="comment">// [1, 2, 3, 4, 5, 6, 7, 8]</span></span><br></pre></td></tr></table></figure><h2 id="打乱数组元素"><a href="#打乱数组元素" class="headerlink" title="打乱数组元素"></a>打乱数组元素</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;)); <span class="comment">// [4, 8, 2, 9, 1, 3, 6, 5, 7]</span></span><br></pre></td></tr></table></figure><h2 id="碾平二维数组"><a href="#碾平二维数组" class="headerlink" title="碾平二维数组"></a>碾平二维数组</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entries = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>], <span class="number">9</span>];</span><br><span class="line"><span class="keyword">var</span> flatEntries = [].concat(...entries); <span class="comment">// [1, 2, 5, 6, 7, 9]</span></span><br></pre></td></tr></table></figure><h2 id="数字转字符串"><a href="#数字转字符串" class="headerlink" title="数字转字符串"></a>数字转字符串</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> convertedNumber = <span class="number">1</span> + <span class="string">""</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> convertedNumber, convertedNumber); <span class="comment">// string 5</span></span><br></pre></td></tr></table></figure><h2 id="字符串转数字"><a href="#字符串转数字" class="headerlink" title="字符串转数字"></a>字符串转数字</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">convertedString = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(+convertedString); <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注意 只有能转成数字的字符串前面加"+"才能转成字符串, 否则返回NaN</span></span><br><span class="line">string = <span class="string">"hello"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(+string); <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h2 id="全部替换"><a href="#全部替换" class="headerlink" title="全部替换"></a>全部替换</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> example = <span class="string">"potato potato"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(example.replace(<span class="regexp">/pot/</span>, <span class="string">"tom"</span>)); <span class="comment">// "tomato potato"</span></span><br><span class="line"><span class="built_in">console</span>.log(example.replace(<span class="regexp">/pot/g</span>, <span class="string">"tom"</span>)); <span class="comment">// "tomato tomato"</span></span><br></pre></td></tr></table></figure><h2 id="使用短路运算符"><a href="#使用短路运算符" class="headerlink" title="使用短路运算符"></a>使用短路运算符</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (available) &#123;</span><br><span class="line">  addToCart();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过简单地使用变量和函数来缩短它</span></span><br><span class="line"></span><br><span class="line">available &amp;&amp; addToCart();</span><br></pre></td></tr></table></figure><h2 id="动态属性名"><a href="#动态属性名" class="headerlink" title="动态属性名"></a>动态属性名</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> dynamic = <span class="string">'flavour'</span>;</span><br><span class="line"><span class="keyword">var</span> item = &#123;</span><br><span class="line">  name: <span class="string">'Coke'</span>,</span><br><span class="line">  [dynamic]: <span class="string">'Cherry'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// &#123; name: "Coke", flavour: "Cherry" &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://huangkun.host/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://huangkun.host/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>vue函数式组件</title>
    <link href="http://huangkun.host/2020/03/25/20191023-vue%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/"/>
    <id>http://huangkun.host/2020/03/25/20191023-vue%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/</id>
    <published>2020-03-25T07:36:28.427Z</published>
    <updated>2020-03-25T08:21:58.526Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是函数式组件"><a href="#什么是函数式组件" class="headerlink" title="什么是函数式组件"></a>什么是函数式组件</h2><p>函数组件(不要与 Vue 的 render 函数混淆)是一个<strong>不包含状态和实例的组件</strong>。</p><p>简单的说，就是组件不支持响应式，并且不能通过 this 关键字引用自己。</p><h2 id="函数式组件的特点"><a href="#函数式组件的特点" class="headerlink" title="函数式组件的特点"></a>函数式组件的特点</h2><ul><li>没有管理任何状态</li><li>没有监听任何传递给它的状态</li><li>没有生命周期方法</li><li>它只是接收一些prop的函数</li></ul><h2 id="访问组件属性"><a href="#访问组件属性" class="headerlink" title="访问组件属性"></a>访问组件属性</h2><p>没有状态或实例，你可能会好奇如何引用数据或方法，Vue为底层的 render 函数提供一个 context 参数对象。</p><p>这个 context 参数对象具有下列属性：</p><p>props: 所有的 props 对象<br>children: VNode 子节点数组<br>scopedSlots: (vue2.6.0+) 暴露传入作用域插槽的对象。将普通插槽作为函数暴露出去<br>data: 全部的数据对象,作为 createElement 函数的第二个参数传递给组件<br>parent: 对父组件的引用<br>listeners: (vue2.3.0+) 包含父级注册的事件侦听器的对象。也是 data.on 的别名<br>injections: (v2.3.0+)  如果使用了 inject 选项，则该对象包含了应当被注入的属性</p><p>访问这个 context 参数非常简单，例如，我们想使用 props，可以这样做：</p><ol><li>在 Template 中访问组件的 context:</li></ol><p><img src="/" alt="template" class="lazyload" data-src="../../assets/images/functional-comp-template.jpg"></p><ol start="2"><li>在 render 函数中访问组件的 context</li></ol><p><img src="/" alt="render" class="lazyload" data-src="../../assets/images/functional-comp-render.jpg"></p><h2 id="函数式组件的优点"><a href="#函数式组件的优点" class="headerlink" title="函数式组件的优点"></a>函数式组件的优点</h2><h3 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h3><p>因为函数式组件没有状态，所以它们不需要像Vue的响应式系统一样需要经过额外的初始化。</p><p>函数式组件仍然会对相应的变化做出响应式改变，比如新传入新的 props，但是在组件本身中，它无法知道数据何时发生了更改，因为它不维护自己的状态。</p><p>我做了一个基准测试，渲染1000个列表(&lt;li&gt;)，有状态组件和函数式组件，有状态组件耗时110 ~ 120ms，函数式组件耗时20 ~ 30ms。</p><p>对于大型应用程序，在使用函数式组件之后，你会看到DOM的渲染、更新会有重大改进。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="vue" scheme="http://huangkun.host/categories/vue/"/>
    
    
      <category term="vue" scheme="http://huangkun.host/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>仿vue-cli搭建属于自己的脚手架</title>
    <link href="http://huangkun.host/2020/03/25/20191006-%E4%BB%BFvue-cli%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/"/>
    <id>http://huangkun.host/2020/03/25/20191006-%E4%BB%BFvue-cli%E6%90%AD%E5%BB%BA%E5%B1%9E%E4%BA%8E%E8%87%AA%E5%B7%B1%E7%9A%84%E8%84%9A%E6%89%8B%E6%9E%B6/</id>
    <published>2020-03-25T07:36:28.426Z</published>
    <updated>2020-03-25T08:21:57.196Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是脚手架"><a href="#什么是脚手架" class="headerlink" title="什么是脚手架"></a>什么是脚手架</h2><p>脚手架就是个工具，<strong>方便我们新建项目用的工具</strong>，有了这个项目我们就能直接通过几行命令, 再通过配置就可以开发了</p><p>想想我们平时开发一个新项目, 基本上我们可以用 git clone url 来新建(复制)项目, 或者这个复制粘贴整个文件夹</p><p>首先要基本了解<a href="https://cli.vuejs.org/" target="_blank" rel="noopener">vue-cli(@vue/cli)</a>是怎么工作的</p><p>脚手架的本质也是从远程下载一个模板来进行新的项目, 所以, 有什么不同呢? 就高大上啊😳, 当然不止于此, 脚手架是高级版的克隆, 它提供了交互式的命令让我们可以动态的更改模板/其他配置项, 然后用命令就可以搞定了</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="commander"><a href="#commander" class="headerlink" title="commander"></a><a href="https://www.npmjs.com/package/commander" target="_blank" rel="noopener">commander</a></h3><p>这是用来编写指令和处理命令行的，具体用法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">"commander"</span>);</span><br><span class="line"><span class="comment">// 定义指令</span></span><br><span class="line">program</span><br><span class="line">  .version(<span class="string">'0.0.1'</span>)</span><br><span class="line">  .command(<span class="string">'init'</span>, <span class="string">'Generate a new project from a template'</span>)</span><br><span class="line">  .action(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调函数</span></span><br><span class="line">  &#125;)</span><br><span class="line"><span class="comment">// 解析命令行参数</span></span><br><span class="line">program.parse(process.argv);</span><br></pre></td></tr></table></figure><p>回忆一下，我们曾用过的 vue init/create 命令就是这样声明的。</p><h3 id="inquirer"><a href="#inquirer" class="headerlink" title="inquirer"></a><a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="noopener">inquirer</a></h3><p>强大的交互式命令行工具，具体用法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">'inquirer'</span>);</span><br><span class="line">inquirer</span><br><span class="line">  .prompt([</span><br><span class="line">    <span class="comment">// 一些交互式的问题</span></span><br><span class="line">  ])</span><br><span class="line">  .then(<span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 回调函数，answers 就是用户输入的内容，是个对象</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>想象一下我们用 vue init webpack project-name 之后是不是会有几个交互问题，问你文件名啊、作者啊、描述啊、要不要用 eslint 啊等等之类的，就是用这个来写的。</p><h3 id="chalk"><a href="#chalk" class="headerlink" title="chalk"></a><a href="https://www.npmjs.com/package/chalk" target="_blank" rel="noopener">chalk</a></h3><p>这是用来修改控制台输出内容样式的，比如颜色啊，具体用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(chalk.green(<span class="string">'success'</span>));</span><br><span class="line"><span class="built_in">console</span>.log(chalk.red(<span class="string">'error'</span>));</span><br></pre></td></tr></table></figure><h3 id="ora"><a href="#ora" class="headerlink" title="ora"></a><a href="https://www.npmjs.com/package/ora" target="_blank" rel="noopener">ora</a></h3><p>这是一个好看的加载，就是你下载的时候会有个转圈圈的那种效果，用法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ora = <span class="built_in">require</span>(<span class="string">'ora'</span>)</span><br><span class="line"><span class="keyword">let</span> spinner = ora(<span class="string">'downloading template ...'</span>)</span><br><span class="line">spinner.start()</span><br></pre></td></tr></table></figure><h3 id="download-git-repo"><a href="#download-git-repo" class="headerlink" title="download-git-repo"></a><a href="https://www.npmjs.com/package/download-git-repo" target="_blank" rel="noopener">download-git-repo</a></h3><p>看名字很明显了，这是用来下载远程模板的，支持 GitHub、 GitLab 和 Bitbucket 等，用法如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> download = <span class="built_in">require</span>(<span class="string">'download-git-repo'</span>)</span><br><span class="line">download(repository, destination, options, callback)</span><br></pre></td></tr></table></figure><p>其中 repository 是远程仓库地址；destination 是存放下载的文件路径，也可以直接写文件名，默认就是当前目录；options 是一些选项，比如 { clone：boolean } 表示用 http download 还是 git clone 的形式下载。</p><h2 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h2><p>有了上面的知识储备后, 我们就正式开始撸代码了</p><ol><li>首先我们创建一个文件夹, 取名为 demo-cli</li><li>在改目录下执行 <code>npm init -y</code> 命令, 在生成的 package.json 文件中写入以下依赖并执行 <code>npm install</code> 安装, 如下</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"dependencies": &#123;</span><br><span class="line">  "chalk": "^2.4.2",</span><br><span class="line">  "commander": "^2.19.0",</span><br><span class="line">  "download-git-repo": "^1.1.0",</span><br><span class="line">  "inquirer": "^6.2.2",</span><br><span class="line">  "ora": "^3.2.0"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>新建一个 bin 文件夹, 在 bin 文件夹下新建一个无后缀名的 demo 文件, 并写上:</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure><p>这个文件就是我们整个脚手架的入口文件, 我们用 <code>node ./bin/demo</code> 运行一下, 就可以看到在控制台打印出 hello</p><p>这里要注意开头的 #!/usr/bin/env node 这个语句必须加上，主要是为了让系统看到这一行的时候，会沿着该路径去查找 node 并执行，主要是为了兼容 Mac ，确保可执行。</p><h3 id="bin-目录初始化"><a href="#bin-目录初始化" class="headerlink" title="bin 目录初始化"></a>bin 目录初始化</h3><p>当前，bin 目录下就只有一个文件，就是入口文件 demo。所以现在我们先来编写这个文件，由于内容较少，我们直接看代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"><span class="keyword">const</span> program = <span class="built_in">require</span>(<span class="string">'commander'</span>);</span><br><span class="line"></span><br><span class="line">program</span><br><span class="line">  .version(<span class="built_in">require</span>(<span class="string">'../package'</span>).version, <span class="string">'-V, --version'</span>) <span class="comment">// 定义当前版本</span></span><br><span class="line">  .usage(<span class="string">'&lt;command&gt; [options]'</span>) <span class="comment">// 定义使用方法</span></span><br><span class="line">  .command(<span class="string">'add'</span>, <span class="string">'add a new template'</span>) <span class="comment">// 定义四个指令</span></span><br><span class="line">  .command(<span class="string">'delete'</span>, <span class="string">'delete a template'</span>)</span><br><span class="line">  .command(<span class="string">'list'</span>, <span class="string">'list all the template'</span>)</span><br><span class="line">  .command(<span class="string">'init'</span>, <span class="string">'generate a new project from a template'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析命令行参数</span></span><br><span class="line">program.parse(process.argv)</span><br></pre></td></tr></table></figure><p>这个文件的主要作用就是定义指令，现在我们用 node ./bin/demo 运行一下，就能看到如下结果：</p><p><img src="/" alt="commander" class="lazyload" data-src="../../assets/images/command.jpg"></p><p>当然，你可能会觉得每次输入 node ./bin/demo 这个命令有点麻烦，没关系，我们可以在 package.json 里面写入已下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bin 用来指定每个命令所对应的可执行文件的位置</span></span><br><span class="line"><span class="string">"bin"</span>: &#123;</span><br><span class="line">  <span class="string">"demo"</span>: <span class="string">"bin/demo"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在根目录下执行 <code>npm link</code>（就是把命令挂载到全局的意思），这样我们每次只要输入 demo，就可以直接运行了，so cool</p><p>是不是好像有点样子了呢😁😁😁，那就让我们继续完善下 bin 目录吧！ok，让我们在 bin 目录下再新建四个文件，分别对应上面的四个指令，然后分别处理四个指令要做的事情</p><p>同样的，我们修改一下 package.json 里面的 bin 内容，如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">"bin": &#123;</span><br><span class="line">  "demo": "bin/demo",</span><br><span class="line">  "demo-add": "bin/demo-add",</span><br><span class="line">  "demo-delete": "bin/demo-delete",</span><br><span class="line">  "demo-list": "bin/demo-list",</span><br><span class="line">  "demo-init": "bin/demo-init"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后执行 npm unlink 解绑全局命令，再执行 npm link 重新把命令绑定到全局</p><p>最后顺便在根目录下新建一个 template.json 文件，里面的内容就是一个 {}。</p><h2 id="编写具体指令"><a href="#编写具体指令" class="headerlink" title="编写具体指令"></a>编写具体指令</h2><p>好了，一切准备就绪，接下来就让我们来写下具体的四个指令吧。</p><h3 id="demo-add"><a href="#demo-add" class="headerlink" title="demo-add"></a>demo-add</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交互式命令行</span></span><br><span class="line"><span class="keyword">const</span> inquirer = <span class="built_in">require</span>(<span class="string">'inquirer'</span>)</span><br><span class="line"><span class="comment">// 修改控制台字符串的样式</span></span><br><span class="line"><span class="keyword">const</span> chalk = <span class="built_in">require</span>(<span class="string">'chalk'</span>)</span><br><span class="line"><span class="comment">// node 内置文件模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line"><span class="comment">// 读取根目录下的 template.json</span></span><br><span class="line"><span class="keyword">const</span> tplObj = <span class="built_in">require</span>(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/../template`</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义交互式命令行的问题及简单的校验</span></span><br><span class="line"><span class="keyword">let</span> question = [</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"name"</span>,</span><br><span class="line">    type: <span class="string">'input'</span>,</span><br><span class="line">    message: <span class="string">"请输入模板名称"</span>,</span><br><span class="line">    validate (val) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val === <span class="string">''</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Name is required!'</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tplObj[val]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Template has already existed!'</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    name: <span class="string">"url"</span>,</span><br><span class="line">    type: <span class="string">'input'</span>,</span><br><span class="line">    message: <span class="string">"请输入模板地址"</span>,</span><br><span class="line">    validate (val) &#123;</span><br><span class="line">      <span class="keyword">if</span> (val === <span class="string">''</span>) <span class="keyword">return</span> <span class="string">'The url is required!'</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">inquirer</span><br><span class="line">  .prompt(question).then(<span class="function"><span class="params">answers</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// answers 就是用户输入的内容，是个对象</span></span><br><span class="line">    <span class="keyword">let</span> &#123; name, url &#125; = answers;</span><br><span class="line">    <span class="comment">// 过滤 unicode 字符</span></span><br><span class="line">    tplObj[name] = url.replace(<span class="regexp">/[\u0000-\u0019]/g</span>, <span class="string">''</span>)</span><br><span class="line">    <span class="comment">// 把模板信息写入 template.json 文件中</span></span><br><span class="line">    fs.writeFile(<span class="string">`<span class="subst">$&#123;__dirname&#125;</span>/../template.json`</span>, <span class="built_in">JSON</span>.stringify(tplObj), <span class="string">'utf-8'</span>, err =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(err)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'\n'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(chalk.green(<span class="string">'Added successfully!\n'</span>))</span><br><span class="line">      <span class="built_in">console</span>.log(chalk.grey(<span class="string">'The latest template list is: \n'</span>))</span><br><span class="line">      <span class="built_in">console</span>.log(tplObj)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'\n'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="前端工程化" scheme="http://huangkun.host/categories/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    
      <category term="javascript" scheme="http://huangkun.host/tags/javascript/"/>
    
      <category term="前端工程化" scheme="http://huangkun.host/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>事件的节流和防抖</title>
    <link href="http://huangkun.host/2020/03/25/20190929-%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/"/>
    <id>http://huangkun.host/2020/03/25/20190929-%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%8A%82%E6%B5%81%E5%92%8C%E9%98%B2%E6%8A%96/</id>
    <published>2020-03-25T07:36:28.425Z</published>
    <updated>2020-03-25T08:21:51.412Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有些浏览器事件可以在短时间内快速触发多次，比如<strong>调整窗口大小</strong>或向下<strong>滚动页面</strong>。例如，监听页面窗口滚动事件，并且用户持续快速地向下滚动页面，那么滚动事件可能在 3 秒内触发数千次，这可能会导致一些严重的性能问题。</p><p>如果在面试中讨论构建应用程序，出现滚动、窗口大小调整或按下键等事件请务必提及 防抖(Debouncing) 和 函数节流（Throttling）来提升页面速度和性能。这两兄弟的本质都是以闭包的形式存在。通过对事件对应的回调函数进行包裹、以自由变量的形式缓存时间信息，最后用 setTimeout 来控制事件的触发频率。</p><h2 id="Throttle-第一个人说了算"><a href="#Throttle-第一个人说了算" class="headerlink" title="Throttle  第一个人说了算"></a>Throttle  第一个人说了算</h2><p>throttle 的主要思想：在某段时间内，不管你触发了多少次回调，都只认第一次，并在计时结束时给予响应。</p><p>现在就来实现一个简单的 throttle</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * generate a throttling function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>fn The callback of event</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>interval time interval</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now - last &gt;= interval) &#123;</span><br><span class="line">      last = now</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> betterScroll = throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'滚动事件触发'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, betterScroll)</span><br></pre></td></tr></table></figure><hr /><h2 id="Debounce-最后一个参赛者说了算"><a href="#Debounce-最后一个参赛者说了算" class="headerlink" title="Debounce  最后一个参赛者说了算"></a>Debounce  最后一个参赛者说了算</h2><p>Debounce 的主要思想：我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次。</p><p>现在就来实现一个简单的 Debounce</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * generate a debounce function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>fn The callback of event</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>delay time interval</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设立新定时器</span></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用debounce来包装scroll的回调</span></span><br><span class="line"><span class="keyword">const</span> betterScroll = debounce(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'滚动事件触发'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, betterScroll)</span><br></pre></td></tr></table></figure><hr /><h2 id="用-Throttle-来优化-Debounce"><a href="#用-Throttle-来优化-Debounce" class="headerlink" title="用 Throttle 来优化 Debounce"></a>用 Throttle 来优化 Debounce</h2><p>debounce 的问题在于它“太有耐心了”。试想，如果用户的操作十分频繁——他每次都不等 debounce 设置的 delay 时间结束就进行下一次操作，于是每次 debounce 都为该用户重新生成定时器，回调函数被延迟了不计其数次。频繁的延迟会导致用户迟迟得不到响应，用户同样会产生“这个页面卡死了”的观感。</p><p>为了避免弄巧成拙，我们需要借力 throttle 的思想，打造一个“有底线”的 debounce——等你可以，但我有我的原则：delay 时间内，我可以为你重新生成定时器；但只要delay的时间到了，我必须要给用户一个响应。这个 throttle 与 debounce “合体”思路，已经被很多成熟的前端库应用到了它们的加强版 throttle 函数的实现中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * generate a throttle function</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Function&#125;</span> </span>fn The callback of event</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;Number&#125;</span> </span>delay time interval</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> last = <span class="number">0</span>, timer = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> context = <span class="keyword">this</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (now - last &lt; delay) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line"></span><br><span class="line">      timer = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        last = now</span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      last = now</span><br><span class="line"></span><br><span class="line">      fn.apply(context, args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> betterScroll = throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'滚动事件触发'</span>)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'scroll'</span>, betterScroll)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://huangkun.host/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://huangkun.host/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Commit message 和 Change log 编写指南</title>
    <link href="http://huangkun.host/2020/03/25/20191005-commit-msg%E5%92%8Cchangelog/"/>
    <id>http://huangkun.host/2020/03/25/20191005-commit-msg%E5%92%8Cchangelog/</id>
    <published>2020-03-25T07:36:28.425Z</published>
    <updated>2020-03-25T08:21:55.690Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m "hello world"</span><br></pre></td></tr></table></figure><p>如果不写 -m 及后面的信息, 命令行会进入 vim 模式, 让你输入详细的 commit 信息</p><p><img src="/" alt="commit" class="lazyload" data-src="../../assets/images/commit-vim.jpg"></p><p>一般来说, commit 信息应该清晰明了, </p><p>按照 Angular 开发团队的代码提交规范</p><ul><li>[feat]: A new feature</li><li>[fix]: A bug fix</li><li>[docs]: Documentation only changes</li><li>[style]: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)</li><li>[refactor]: A code change that neither fixes a bug nor adds a feature</li><li>[perf]: A code change that improves performance</li><li>[test]: Adding missing or correcting existing tests</li><li>[chore]: Changes to the build process or auxiliary tools and libraries such as documentation generation</li></ul><p>详情可 <a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0" target="_blank" rel="noopener">参考此处</a></p><h2 id="Commit-message-的作用"><a href="#Commit-message-的作用" class="headerlink" title="Commit message 的作用"></a>Commit message 的作用</h2><p>格式化的Commit message，有几个好处。</p><p>（1）提供更多的历史信息，方便快速浏览。</p><p>可以用以下命令来 快速的查看 commit message 的相关信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=format:"%C(auto)%h %ad | %C(auto)%s%d  %Cblue(%an)" --date=short</span><br></pre></td></tr></table></figure><p>（2）可以过滤某些commit（比如文档改动），便于快速查找信息。</p><p>（3）可以直接从commit生成Change log。</p><h2 id="Commit-message-的格式"><a href="#Commit-message-的格式" class="headerlink" title="Commit message 的格式"></a>Commit message 的格式</h2><p>每次提交，Commit message 都包括三个部分：Header，Body 和 Footer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&#x2F;&#x2F; 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，Header 是必需的，Body 和 Footer 可以省略。</p><p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p><h2 id="生成-Change-log"><a href="#生成-Change-log" class="headerlink" title="生成 Change log"></a>生成 Change log</h2><p><a href="https://github.com/ajoslin/conventional-changelog" target="_blank" rel="noopener">conventional-changelog</a> 就是生成 Change log 的工具，运行下面的命令即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g conventional-changelog</span><br><span class="line">cd my-project</span><br><span class="line">conventional-changelog -p angular -i CHANGELOG.md -w</span><br></pre></td></tr></table></figure><p>如果你想生成所有发布的 Change log，要改为运行下面的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conventional-changelog -p angular -i CHANGELOG.md -w -r 0</span><br></pre></td></tr></table></figure><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><p><a href="https://github.com/angular/angular/commits/master" target="_blank" rel="noopener">https://github.com/angular/angular/commits/master</a></p><p><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html</a></p><p><a href="https://www.npmjs.com/package/conventional-changelog-cli" target="_blank" rel="noopener">https://www.npmjs.com/package/conventional-changelog-cli</a></p><p><a href="https://github.com/ajoslin/conventional-changelog" target="_blank" rel="noopener">https://github.com/ajoslin/conventional-changelog</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="git" scheme="http://huangkun.host/categories/git/"/>
    
    
      <category term="git" scheme="http://huangkun.host/tags/git/"/>
    
      <category term="代码规范" scheme="http://huangkun.host/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>在循环中使用闭包</title>
    <link href="http://huangkun.host/2020/03/25/20190927-%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85/"/>
    <id>http://huangkun.host/2020/03/25/20190927-%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E4%BD%BF%E7%94%A8%E9%97%AD%E5%8C%85/</id>
    <published>2020-03-25T07:36:28.424Z</published>
    <updated>2020-03-25T08:21:37.483Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><p>编写一个函数，该函数将遍历整数列表，并在延迟3秒后打印每个元素的索引。</p><p>经常<strong>不正确</strong>的写法是这样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">3000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果运行上面的代码, 3秒后你会看到 打印 5个5, 而不是0,1,2,3,4</span></span><br></pre></td></tr></table></figure><p>原因是因为 setTimeout 函数创建了一个可以访问其外部作用域的函数（闭包），该作用域是包含索引 i 的循环。 经过 3 秒后，执行该函数并打印出 i 的值，该值在循环结束时为 4，因为它循环经过0,1,2,3,4并且循环最终停止在 4。</p><p>实际上有多处方法来正确的解这道题：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params">i_local</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(i_local);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;(i), <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://huangkun.host/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://huangkun.host/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>事件委托代理</title>
    <link href="http://huangkun.host/2020/03/25/20190922-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%BB%A3%E7%90%86/"/>
    <id>http://huangkun.host/2020/03/25/20190922-%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E4%BB%A3%E7%90%86/</id>
    <published>2020-03-25T07:36:28.423Z</published>
    <updated>2020-03-25T08:21:42.495Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="事件委托是什么"><a href="#事件委托是什么" class="headerlink" title="事件委托是什么"></a>事件委托是什么</h2><p>事件：通俗的讲, 就是onclick, onmouseenter, onmouseover, onmouseout… 等等</p><p>委托：通俗的讲, 就是让别人来做</p><p>那么事件委托就是：这个事件本来是加在某些元素上的, 然而你却加到别人身上来做, 来完成这个事件, <strong>也就是利用冒泡原理, 把事件加到父级上, 触发执行结果</strong></p><p>事件委托就是利用事件冒泡机制指定一个事件处理程序，来管理某一类型的所有事件。</p><h2 id="事件委托的好处"><a href="#事件委托的好处" class="headerlink" title="事件委托的好处"></a>事件委托的好处</h2><ol><li>提高性能(只在内存中开辟了一块空间，节省资源同时减少了dom操作)</li><li>新添加的元素还会有之前的事件</li></ol><p>我们来看一个例子:  需要触发每个 li 来改变他们的背景颜色</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"ul"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">"ul"</span>);</span><br><span class="line">  <span class="keyword">var</span> aLi = oUl.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;aLi.length; i++)&#123;</span><br><span class="line">    aLi[i].onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.style.background = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    aLi[i].onmouseout = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.style.background = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以做到li上面添加鼠标事件。</p><p>但是如果说我们可能有很多个li用for循环的话就比较影响性能。</p><hr /><p>下面我们可以用事件委托的方式来实现这样的效果。html不变</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oUl = <span class="built_in">document</span>.getElementById(<span class="string">"ul"</span>);</span><br><span class="line">  <span class="keyword">var</span> aLi = oUl.getElementsByTagName(<span class="string">"li"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  这里要用到事件源：event 对象，事件源，不管在哪个事件中，只要你操作的那个元素就是事件源。</span></span><br><span class="line"><span class="comment">  ie：window.event.srcElement</span></span><br><span class="line"><span class="comment">  标准下:event.target</span></span><br><span class="line"><span class="comment">  nodeName:找到元素的标签名</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  oUl.onmouseover = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> target = ev.target || ev.srcElement;</span><br><span class="line">    <span class="comment">//alert(target.innerHTML);</span></span><br><span class="line">    <span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">"li"</span>)&#123;</span><br><span class="line">    target.style.background = <span class="string">"red"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  oUl.onmouseout = <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ev = ev || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> target = ev.target || ev.srcElement;</span><br><span class="line">    <span class="comment">//alert(target.innerHTML);</span></span><br><span class="line">    <span class="keyword">if</span>(target.nodeName.toLowerCase() == <span class="string">"li"</span>)&#123;</span><br><span class="line">    target.style.background = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://huangkun.host/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://huangkun.host/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>Git-stash</title>
    <link href="http://huangkun.host/2020/03/25/20190920-Git-stash/"/>
    <id>http://huangkun.host/2020/03/25/20190920-Git-stash/</id>
    <published>2020-03-25T07:36:28.422Z</published>
    <updated>2020-03-25T08:21:50.674Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们目前在做的项目, 采用的是快速迭代的方式, 开发和测试和用户测试和改bug并行, 经常要切分支.</p><p>一个人可能要同时管理以下分支</p><ul><li>dev =&gt; 开发分支</li><li>sit =&gt; 测试人员测试的的分支</li><li>uat =&gt; 用户测试的分支</li><li>hot-fix-xxx =&gt; 生产问题修复的分支</li><li>930 =&gt; 截止日期为 9月30日 要上线的功能的分支</li><li>1030 =&gt; 截止日期为 10月30日 要上线功能的分支</li><li>…</li></ul><p>并且分支切的很勤, 因为经常生产问题当天要解决并发版, 有的bug在特定的环境才能重现, 不切分支过去看不行 ……</p><p>所以经常用到 <em>stash</em> 命令, 遂系统的查询了一下 <em>stash</em> 的使用</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>存放；贮藏</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><blockquote><p>常用</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash save "save message"</span><br><span class="line">// 执行存储时, 添加备注, 方便查找, 只有git stash 也要可以的, 但查找时不方便识别</span><br></pre></td></tr></table></figure><p>注意  没有在git 版本控制中的文件，是不能被git stash 存起来的<br>很明显，先执行下git add 加到git版本控制中，然后再git stash就可以了</p><p>但是：git add 只是把文件加到git 版本控制里，并不等于就被stash起来了，git add和git stash 没有必然的关系，但是执行git stash 能正确存储的前提是文件必须在git 版本控制中才行。</p><hr /><blockquote><p>list</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git stash list</span><br><span class="line">// 查看stash了哪些存储</span><br><span class="line">// stash@&#123;0&#125;: On _1030/expense-ecc: just test stash</span><br><span class="line">// stash@&#123;1&#125;: WIP on _1030/expense-ec: d621525d fix: bug fixed</span><br><span class="line">// stash@&#123;2&#125;: WIP on _1030/expense-ec: 8bebefb0 fix: bug fixed</span><br><span class="line">// stash@&#123;3&#125;: WIP on _1030/expense-ec: ab7180a2 fix: bug fixed</span><br></pre></td></tr></table></figure><hr /><blockquote><p>show</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">git stash show</span><br><span class="line">// 显示做了哪些改动, 默认show第一个存储,如果要显示其他存贮, 后面加stash@&#123;$num&#125;</span><br><span class="line">// 比如第二个 git stash show stash@&#123;1&#125;</span><br><span class="line"></span><br><span class="line">git stash show -p</span><br><span class="line">// 显示第一个存储的改动(改动的详情)</span><br><span class="line">// 如果想显示其他存存储</span><br><span class="line">// eg. git stash show -p stash@&#123;$num&#125; $num为第几个存储</span><br></pre></td></tr></table></figure><hr /><blockquote><p>apply</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash apply</span><br><span class="line">// 应用某个存储, 但不会把存储从存储列表中删除看, 默认使用第一个存储, 即stash@&#123;0&#125;</span><br><span class="line">// 如果要使用其他存储</span><br><span class="line">// eg. git stash apply stash@&#123;$num&#125; $num为第几个存储</span><br></pre></td></tr></table></figure><hr /><blockquote><p>pop</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git stash pop</span><br><span class="line">// 命令恢复之前缓存的工作目录，将缓存堆栈中的对应stash删除，并将对应修改应用到当前的工作目录下, 默认为第一个stash, 即stash@&#123;0&#125;，</span><br><span class="line">// 如果要应用并删除其他stash</span><br><span class="line">// eg. git stash pop stash@&#123;$num&#125; $num为第几个存储</span><br></pre></td></tr></table></figure><hr /><blockquote><p>drop</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash drop stash@&#123;$num&#125;</span><br><span class="line">// 丢弃stash@&#123;$num&#125;存储，从列表中删除这个存储</span><br></pre></td></tr></table></figure><hr /><blockquote><p>clear</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git stash clear</span><br><span class="line">// 删除所有缓存的stash</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="git" scheme="http://huangkun.host/categories/git/"/>
    
    
      <category term="git" scheme="http://huangkun.host/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Vue面试题</title>
    <link href="http://huangkun.host/2020/03/25/20190823-Vue%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://huangkun.host/2020/03/25/20190823-Vue%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-03-25T07:36:28.420Z</published>
    <updated>2020-03-25T08:22:39.299Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-SPA是什么-优缺点是什么"><a href="#1-SPA是什么-优缺点是什么" class="headerlink" title="1. SPA是什么, 优缺点是什么"></a>1. SPA是什么, 优缺点是什么</h2><p>SPA (single-page application) 单页面应用程序, 仅在 web 页面初始化的时候加载响应的HTML, JavaScript, CSS. 一旦页面加载完成, SPA 不会因为用户的操作而进行页面的重新加载或跳转, 取而代之的是利用路由机制实现 HTML 内容的变换, UI 与用户的交互, 避免页面的重新加载, 当然可以在 JS 代码中强制实现页面的重新加载.</p><p><em>优点</em></p><ul><li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li><li>基于上面一点，SPA 相对对服务器压力小；</li><li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li></ul><p><em>缺点</em></p><ul><li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li><li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li><li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li></ul><hr /><h2 id="2-v-show-和-v-if-有什么区别"><a href="#2-v-show-和-v-if-有什么区别" class="headerlink" title="2. v-show 和 v-if 有什么区别"></a>2. v-show 和 v-if 有什么区别</h2><p><strong>v-if</strong> 是真正的条件渲染, 因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建, 也是惰性的: 如果在初始渲染时条件为假, 则什么也不做——直到条件第一次变为真时, 才会开始渲染条件块.</p><p><strong>v-show</strong> 不管初始条件是什么, 元素总是会被渲染, 并且只是简单的基于 CSS 的 display 属性进行切换.</p><p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景(会操作DOM)；v-show 则适用于需要非常频繁切换条件的场景</p><hr /><h2 id="3-Class-和-Style-如何动态绑定"><a href="#3-Class-和-Style-如何动态绑定" class="headerlink" title="3. Class 和 Style 如何动态绑定"></a>3. Class 和 Style 如何动态绑定</h2><p>Class 可以通过对象语法和数组语法进行动态绑定:</p><ul><li><p>对象语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"&#123; active: isActive, 'text-danger': hasError &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  isActive: true,</span><br><span class="line">  hasError: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:class</span>=<span class="string">"[isActive ? activeClass : '', errorClass]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeClass: 'active',</span><br><span class="line">  errorClass: 'text-danger'</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Style 也可以通过对象语法和数组语法进行动态绑定:</p><ul><li><p>对象语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"&#123; color: activeColor, fontSize: fontSize + 'px' &#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  activeColor: 'red',</span><br><span class="line">  fontSize: 30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>数组语法</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:style</span>=<span class="string">"[styleColor, styleSize]"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">data: &#123;</span><br><span class="line">  styleColor: &#123;</span><br><span class="line">    color: 'red'</span><br><span class="line">  &#125;,</span><br><span class="line">  styleSize:&#123;</span><br><span class="line">    fontSize:'23px'</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr /><h2 id="4-怎么理解-Vue-的单项数据流"><a href="#4-怎么理解-Vue-的单项数据流" class="headerlink" title="4. 怎么理解 Vue 的单项数据流"></a>4. 怎么理解 Vue 的单项数据流</h2><p>所有的 prop 都使得其父子 prop 之间形成了一个单向下行绑定：父级 prop 的更新会向下流动到子组件中，但是反过来则不行。这样会防止从子组件意外改变父级组件的状态，从而导致你的应用的数据流向难以理解。</p><p>额外的，每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。这意味着你不应该在一个子组件内部改变 prop。如果你这样做了，Vue 会在浏览器的控制台中发出警告。<strong>子组件想修改时，只能通过 $emit 派发一个自定义事件，父组件接收到后，由父组件修改</strong>。</p><p>有两种常见的试图改变一个 prop 的情形:</p><ul><li><p>这个 prop 用来传递一个初始值, 这个子组件接下来希望将其作为一个本地的 prop 数据来使用. 在这种情况下, 最好定义一个本地的 data 属性并将这个 prop 用作其初始值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [&#39;initialCounter&#39;],</span><br><span class="line">data: function () &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    counter: this.initialCounter</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个 prop 以一种原始的值传入且需要进行转换. 在这种情况下，最好使用这个 prop 的值来定义一个计算属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">props: [<span class="string">'size'</span>],</span><br><span class="line">computed: &#123;</span><br><span class="line">  normalizedSize: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.size.trim().toLowerCase()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><hr /><h2 id="5-computed-和-watch-的却别和适用场景"><a href="#5-computed-和-watch-的却别和适用场景" class="headerlink" title="5. computed 和 watch 的却别和适用场景"></a>5. computed 和 watch 的却别和适用场景</h2><p><em>区别</em></p><ul><li><p>computed: 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值；</p></li><li><p>watch: 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p></li></ul><p><em>适用场景</em></p><ul><li><p>computed: 当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p></li><li><p>watch: 当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p></li></ul><hr /><h2 id="6-直接给一个数组赋值-Vue-能检测到变化吗"><a href="#6-直接给一个数组赋值-Vue-能检测到变化吗" class="headerlink" title="6. 直接给一个数组赋值, Vue 能检测到变化吗"></a>6. 直接给一个数组赋值, Vue 能检测到变化吗</h2><p>由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：</p><ul><li>当你利用索引直接设置一个数组项时，例如：vm.items[indexOfItem] = newValue</li><li>当你修改数组的长度时，例如：vm.items.length = newLength</li></ul><p>为了解决第一个问题，Vue 提供了以下操作方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vue.set</span></span><br><span class="line">Vue.set(vm.items, indexOfItem, newValue)</span><br><span class="line"><span class="comment">// vm.$set，Vue.set的一个别名</span></span><br><span class="line">vm.$<span class="keyword">set</span>(vm.items, indexOfItem, newValue)</span><br><span class="line">// Array.prototype.splice</span><br><span class="line">vm.items.splice(indexOfItem, 1, newValue)</span><br></pre></td></tr></table></figure><p>复制代码为了解决第二个问题，Vue 提供了以下操作方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Array.prototype.splice</span></span><br><span class="line">vm.items.splice(newLength)</span><br></pre></td></tr></table></figure><hr /><h2 id="7-Vue-的生命周期的理解"><a href="#7-Vue-的生命周期的理解" class="headerlink" title="7. Vue 的生命周期的理解"></a>7. Vue 的生命周期的理解</h2><p>7.1. 生命周期是什么</p><p>Vue 实例有一个完整的生命周期，也就是从开始创建、初始化数据、编译模版、挂载 Dom -&gt; 渲染、更新 -&gt; 渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。</p><p>7.2. 各个生命周期的作用</p><table><thead><tr><th>生命周期</th><th>描述</th></tr></thead><tbody><tr><td>beforeCreate</td><td>组件实例被创建之初，组件的属性生效之前</td></tr><tr><td>created</td><td>组件实例已经完全创建，属性也绑定，但真实 dom 还没有生成，$el 还不可用</td></tr><tr><td>beforeMount</td><td>在挂载开始之前被调用：相关的 render 函数首次被调用</td></tr><tr><td>mounted</td><td>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子</td></tr><tr><td>beforeUpdate</td><td>组件数据更新之前调用，发生在虚拟 DOM 打补丁之前</td></tr><tr><td>update</td><td>组件数据更新之后</td></tr><tr><td>activited</td><td>keep-alive 专属，组件被激活时调用</td></tr><tr><td>deadctivated</td><td>keep-alive 专属，组件被销毁时调用</td></tr><tr><td>beforeDestory</td><td>组件销毁前调用</td></tr><tr><td>destoryed</td><td>组件销毁后调用</td></tr></tbody></table><hr /><h2 id="8-Vue-父组件和子组件生命周期钩子函数的执行顺序"><a href="#8-Vue-父组件和子组件生命周期钩子函数的执行顺序" class="headerlink" title="8. Vue 父组件和子组件生命周期钩子函数的执行顺序"></a>8. Vue 父组件和子组件生命周期钩子函数的执行顺序</h2><p>Vue 的父组件和子组件生命周期钩子函数执行顺序可以归类为以下 4 部分：</p><p>8.1. 加载渲染过程<br>父 beforeCreate -&gt; 父 created -&gt; 父 beforeMount -&gt; 子 beforeCreate -&gt; 子 created -&gt; 子 beforeMount -&gt; 子 mounted -&gt; 父 mounted</p><p>8.2. 子组件更新过程<br>父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</p><p>8.3. 父组件更新过程<br>父 beforeUpdate -&gt; 父 updated</p><p>8.4. 销毁过程<br>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p><hr /><h2 id="9-在哪个生命周期内调用异步请求-为什么"><a href="#9-在哪个生命周期内调用异步请求-为什么" class="headerlink" title="9. 在哪个生命周期内调用异步请求 ? 为什么"></a>9. 在哪个生命周期内调用异步请求 ? 为什么</h2><p>可以在钩子函数 <em>created<em>、</em>beforeMount<em>、</em>mounted</em> 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值</p><p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点</p><p>能更快获取到服务端数据，减少页面 loading 时间；<br>ssr 不支持 beforeMount 、mounted 钩子函数，所以放在 created 中有助于一致性</p><hr /><h2 id="10-在哪个阶段前才能操作-DOM"><a href="#10-在哪个阶段前才能操作-DOM" class="headerlink" title="10. 在哪个阶段前才能操作 DOM"></a>10. 在哪个阶段前才能操作 DOM</h2><p>在钩子函数 mounted 被调用前，Vue 已经将编译好的模板挂载到页面上，所以在 mounted 中可以访问操作 DOM</p><hr /><h2 id="11-父组件可以监听子组件的生命周期吗"><a href="#11-父组件可以监听子组件的生命周期吗" class="headerlink" title="11. 父组件可以监听子组件的生命周期吗"></a>11. 父组件可以监听子组件的生命周期吗</h2><p>比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parent.vue</span></span><br><span class="line">&lt;Child @mounted=<span class="string">"doSomething"</span>/&gt;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// Child.vue</span></span><br><span class="line">mounted() &#123;</span><br><span class="line">  <span class="keyword">this</span>.$emit(<span class="string">"mounted"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Parent.vue</span></span><br><span class="line">&lt;Child @hook:mounted=<span class="string">"doSomething"</span> &gt;&lt;<span class="regexp">/Child&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">doSomething() &#123;</span></span><br><span class="line"><span class="regexp">   console.log('父组件监听到 mounted 钩子函数 ...');</span></span><br><span class="line"><span class="regexp">&#125;,</span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/  Child.vue</span></span><br><span class="line"><span class="regexp">mounted()&#123;</span></span><br><span class="line"><span class="regexp">   console.log('子组件触发 mounted 钩子函数 ...');</span></span><br><span class="line"><span class="regexp">&#125;,    </span></span><br><span class="line"><span class="regexp">    </span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 以上输出顺序为：</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 子组件触发 mounted 钩子函数 ...</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 父组件监听到 mounted 钩子函数 ...</span></span><br></pre></td></tr></table></figure><p>当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听</p><hr /><h2 id="12-谈谈你对-keep-alive-的了解"><a href="#12-谈谈你对-keep-alive-的了解" class="headerlink" title="12. 谈谈你对 keep-alive 的了解"></a>12. 谈谈你对 keep-alive 的了解</h2><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul><hr /><h2 id="13-组件中的-data-为什么是一个对象"><a href="#13-组件中的-data-为什么是一个对象" class="headerlink" title="13. 组件中的 data 为什么是一个对象"></a>13. 组件中的 data 为什么是一个对象</h2><p>为什么组件中的 data 必须是一个函数，然后 return 一个对象，而 new Vue 实例里，data 可以直接是一个对象？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// data</span></span><br><span class="line">data() &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">message: <span class="string">"子组件"</span>,</span><br><span class="line">childName: <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new Vue</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  el: <span class="string">'#app'</span>,</span><br><span class="line">  router,</span><br><span class="line">  template: <span class="string">'&lt;App/&gt;'</span>,</span><br><span class="line">  components: &#123;App&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题</p><hr /><h2 id="14-v-model-的原理"><a href="#14-v-model-的原理" class="headerlink" title="14. v-model 的原理"></a>14. v-model 的原理</h2><p>vue 项目中主要使用 v-model 指令在表单 input、textarea、select 等元素上创建双向数据绑定, v-model 本质上不过是语法糖，v-model 在内部为不同的输入元素使用不同的属性并抛出不同的事件:</p><ul><li>text 和 textarea 元素使用 value 属性和 input 事件；</li><li>checkbox 和 radio 使用 checked 属性和 change 事件；</li><li>select 字段将 value 作为 prop 并将 change 作为事件。</li></ul><p>以 input 表单元素为例子:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input v-model=<span class="string">'something'</span>&gt;</span><br><span class="line">    </span><br><span class="line">相当于</span><br><span class="line"></span><br><span class="line">&lt;input v-bind:value=<span class="string">"something"</span> v-on:input=<span class="string">"something = $event.target.value"</span>&gt;</span><br></pre></td></tr></table></figure><p>如果在自定义组件中，v-model 默认会利用名为 value 的 prop 和名为 input 的事件，如下所示:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">父组件：</span><br><span class="line">&lt;ModelChild v-model=<span class="string">"message"</span>&gt;&lt;<span class="regexp">/ModelChild&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">子组件：</span></span><br><span class="line"><span class="regexp">&lt;div&gt;&#123;&#123;value&#125;&#125;&lt;/</span>div&gt;</span><br><span class="line"></span><br><span class="line">props:&#123;</span><br><span class="line">  value: <span class="built_in">String</span>,</span><br><span class="line">  event: <span class="string">'input'</span>,</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">  test1()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">'input'</span>, <span class="string">'小红'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><hr /><h2 id="15-Vue-组件间有哪几种通信方式"><a href="#15-Vue-组件间有哪几种通信方式" class="headerlink" title="15. Vue 组件间有哪几种通信方式"></a>15. Vue 组件间有哪几种通信方式</h2><p>三大类: 父子组件通信、隔代组件通信、兄弟组件通信，下面我们分别介绍每种通信方式且会说明此种方法可适用于哪类组件间通信</p><p>（1） props / $emit 适用 父子组件通信</p><p>（2） ref 与 $parent / $children 适用 父子组件通信</p><ul><li>ref：如果在普通的 DOM 元素上使用，引用指向的就是 DOM 元素；如果用在子组件上，引用就指向组件实例</li><li>$parent / $children：访问父 / 子实例, 注意子实例是个数组</li></ul><p>（3） EventBus （$emit / $on） 适用于 父子、隔代、兄弟组件通信</p><ul><li>这种方法通过一个空的 Vue 实例作为中央事件总线（事件中心），用它来触发事件和监听事件，从而实现任何组件间的通信，包括父子、隔代、兄弟组件。</li></ul><p>（4） $attrs/$listeners 适用于 隔代组件通信</p><ul><li>$attrs：包含了父作用域中不被 prop 所识别 (且获取) 的特性绑定 ( class 和 style 除外 )。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外 )，并且可以通过 v-bind=”$attrs” 传入内部组件。通常配合 inheritAttrs 选项一起使用。</li><li>$listeners：包含了父作用域中的 (不含 .native 修饰器的) v-on 事件监听器。它可以通过 v-on=”$listeners” 传入内部组件</li></ul><p>（5） provide / inject 适用于 隔代组件通信</p><ul><li>祖先组件中通过 provider 来提供变量，然后在子孙组件中通过 inject 来注入变量。 provide / inject API 主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</li></ul><p>（6） Vuex 适用于 父子、隔代、兄弟组件通信</p><ul><li><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p></li><li><p>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</p></li><li><p>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。</p></li></ul><hr /><h2 id="16-谈谈你对-Vuex-的理解"><a href="#16-谈谈你对-Vuex-的理解" class="headerlink" title="16. 谈谈你对 Vuex 的理解"></a>16. 谈谈你对 Vuex 的理解</h2><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。 （1）Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。 （2）改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样使得我们可以方便地跟踪每一个状态的变化。 主要包括以下几个模块：</p><ul><li>State：定义了应用状态的数据结构，可以在这里设置默认的初始状态。</li><li>Getter：允许组件从 Store 中获取数据，mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性。</li><li>Mutation：是唯一更改 store 中状态的方法，且必须是同步函数。</li><li>Action：用于提交 mutation，而不是直接变更状态，可以包含任意异步操作。</li><li>Module：允许将单一的 Store 拆分为多个 store 且同时保存在单一的状态树中。</li></ul><hr /><h2 id="17-谈谈你对-Vue-SSR-和-SSR-的理解"><a href="#17-谈谈你对-Vue-SSR-和-SSR-的理解" class="headerlink" title="17. 谈谈你对 Vue SSR 和 SSR 的理解"></a>17. 谈谈你对 Vue SSR 和 SSR 的理解</h2><p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记”激活”为客户端上完全可交互的应用程序。 即：SSR大致的意思就是vue在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的html 片段直接返回给客户端这个过程就叫做服务端渲染。</p><p>服务端渲染 SSR 的优缺点如下： </p><p>（1）服务端渲染的优点：</p><ul><li>更好的 SEO： 因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</li><li>更快的内容到达时间（首屏加载更快）： SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</li></ul><p>（2) 服务端渲染的缺点：</p><ul><li>更多的开发条件限制： 例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</li><li>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 ( high traffic ) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li></ul><hr /><h2 id="18-vue-router-路由有几种模式"><a href="#18-vue-router-路由有几种模式" class="headerlink" title="18. vue-router 路由有几种模式"></a>18. vue-router 路由有几种模式</h2><p>vue-router 有 3 种路由模式：hash、history、abstract，对应的源码如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">'history'</span>:</span><br><span class="line"><span class="keyword">this</span>.history = <span class="keyword">new</span> HTML5History(<span class="keyword">this</span>, options.base)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'hash'</span>:</span><br><span class="line"><span class="keyword">this</span>.history = <span class="keyword">new</span> HashHistory(<span class="keyword">this</span>, options.base, <span class="keyword">this</span>.fallback)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">'abstract'</span>:</span><br><span class="line"><span class="keyword">this</span>.history = <span class="keyword">new</span> AbstractHistory(<span class="keyword">this</span>, options.base)</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">'production'</span>) &#123;</span><br><span class="line">  assert(<span class="literal">false</span>, <span class="string">`invalid mode: <span class="subst">$&#123;mode&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，3 种路由模式的说明如下：</p><ul><li><p><em>hash</em>: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器；</p></li><li><p><em>history</em> : 依赖 HTML5 History API 和服务器配置。具体可以查看 HTML5 History 模式；</p></li><li><p><em>abstract</em> : 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式.</p></li></ul><hr /><h2 id="19-谈谈-vue-router-中常用的-hash-和-history-路由模式实现原理"><a href="#19-谈谈-vue-router-中常用的-hash-和-history-路由模式实现原理" class="headerlink" title="19. 谈谈 vue-router 中常用的 hash 和 history 路由模式实现原理"></a>19. 谈谈 vue-router 中常用的 hash 和 history 路由模式实现原理</h2><p>（1）hash 模式的实现原理</p><ul><li>早期的前端路由的实现就是基于 location.hash 来实现的。其实现原理很简单，location.hash 的值就是 URL 中 # 后面的内容。比如下面这个网站，它的 location.hash 的值为 ‘#search’：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:<span class="comment">//www.word.com#search</span></span><br></pre></td></tr></table></figure><p>hash 路由模式的实现主要是基于下面几个特性：</p><ul><li>URL 中 hash 值只是客户端的一种状态，也就是说当向服务器端发出请求时，hash 部分不会被发送；</li><li>hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换；</li><li>可以通过 a 标签，并设置 href 属性，当用户点击这个标签后，URL 的 hash 值会发生改变；或者使用  JavaScript 来对 loaction.hash 进行赋值，改变 URL 的 hash 值；</li><li>我们可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）。</li></ul><p>（2）history 模式的实现原理</p><p>HTML5 提供了 History API 来实现 URL 的变化。其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录，如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.history.pushState(<span class="literal">null</span>, <span class="literal">null</span>, path);</span><br><span class="line"><span class="built_in">window</span>.history.replaceState(<span class="literal">null</span>, <span class="literal">null</span>, path);</span><br></pre></td></tr></table></figure><p>history 路由模式的实现主要基于存在下面几个特性：</p><ul><li>pushState 和 repalceState 两个 API 来操作实现 URL 的变化 ；</li><li>我们可以使用 popstate 事件来监听 url 的变化，从而对页面进行跳转（渲染）；</li><li>history.pushState() 或 history.replaceState() 不会触发 popstate 事件，这时我们需要手动触发页面跳转（渲染）。</li></ul><hr /><h2 id="20-谈谈你对-MVVM-的理解"><a href="#20-谈谈你对-MVVM-的理解" class="headerlink" title="20. 谈谈你对 MVVM 的理解"></a>20. 谈谈你对 MVVM 的理解</h2><p>Model–View–ViewModel （MVVM） 是一个软件架构设计模式，由微软 WPF 和 Silverlight 的架构师 Ken Cooper 和 Ted Peters 开发，是一种简化用户界面的事件驱动编程方式。由 John Gossman（同样也是 WPF 和 Silverlight 的架构师）于2005年在他的博客上发表 MVVM 源自于经典的 Model–View–Controller（MVC）模式 </p><p>MVVM 的出现促进了前端开发与后端业务逻辑的分离，极大地提高了前端开发效率</p><p>MVVM 的核心是 <em>ViewModel</em> 层，它就像是一个中转站（value converter），负责转换 Model 中的数据对象来让数据变得更容易管理和使用，该层向上与视图层进行双向数据绑定，向下与 Model 层通过接口请求进行数据交互，起呈上启下作用。</p><p>（1）View 层</p><p>View 是视图层，也就是用户界面。前端主要由 HTML 和 CSS 来构建 。</p><p>（2）Model 层</p><p>Model 是指数据模型，泛指后端进行的各种业务逻辑处理和数据操控，对于前端来说就是后端提供的 api 接口。</p><p>（3）ViewModel 层</p><p>ViewModel 是由前端开发人员组织生成和维护的视图数据层。在这一层，前端开发者对从后端获取的 Model 数据进行转换处理，做二次封装，以生成符合 View 层使用预期的视图数据模型。需要注意的是 ViewModel 所封装出来的数据模型包括视图的状态和行为两部分，而 Model 层的数据模型是只包含状态的，比如页面的这一块展示什么，而页面加载进来时发生什么，点击这一块发生什么，这一块滚动时发生什么这些都属于视图行为（交互），视图状态和行为都封装在了 ViewModel 里。这样的封装使得 ViewModel 可以完整地去描述 View 层。</p><p>MVVM 框架实现了双向绑定，这样 ViewModel 的内容会实时展现在 View 层，前端开发者再也不必低效又麻烦地通过操纵 DOM 去更新视图，MVVM 框架已经把最脏最累的一块做好了，我们开发者只需要处理和维护 ViewModel，更新数据视图就会自动得到相应更新。这样 View 层展现的不是 Model 层的数据，而是 ViewModel 的数据，由 ViewModel 负责与 Model 层交互，这就完全解耦了 View 层和 Model 层，这个解耦是至关重要的，它是前后端分离方案实施的重要一环。</p><p>我们以下通过一个 Vue 实例来说明 MVVM 的具体实现，有 Vue 开发经验的同学应该一目了然：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View 层</span></span><br><span class="line">&lt;div id=<span class="string">"app"</span>&gt;</span><br><span class="line">  &lt;p&gt;&#123;&#123;message&#125;&#125;&lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">  &lt;button v-on:click="showMessage()"&gt;Click me&lt;/</span>button&gt;</span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ViewModel 层</span></span><br><span class="line"><span class="regexp">var app = new Vue(&#123;</span></span><br><span class="line"><span class="regexp">  el: '#app',</span></span><br><span class="line"><span class="regexp">  data: &#123;  /</span><span class="regexp">/ 用于描述视图状态   </span></span><br><span class="line"><span class="regexp">    message: 'Hello Vue!', </span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  methods: &#123;  /</span><span class="regexp">/ 用于描述视图行为  </span></span><br><span class="line"><span class="regexp">    showMessage()&#123;</span></span><br><span class="line"><span class="regexp">      let vm = this;</span></span><br><span class="line"><span class="regexp">      alert(vm.message);</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">  &#125;,</span></span><br><span class="line"><span class="regexp">  created()&#123;</span></span><br><span class="line"><span class="regexp">    let vm = this;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ Ajax 获取 Model 层的数据</span></span><br><span class="line"><span class="regexp">    ajax(&#123;</span></span><br><span class="line"><span class="regexp">      url: '/y</span>our/server/data/api<span class="string">',</span></span><br><span class="line"><span class="string">      success(res)&#123;</span></span><br><span class="line"><span class="string">        vm.message = res;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">// Model 层</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  "url": "/your/server/data/api",</span></span><br><span class="line"><span class="string">  "res": &#123;</span></span><br><span class="line"><span class="string">    "success": true,</span></span><br><span class="line"><span class="string">    "name": "IoveC",</span></span><br><span class="line"><span class="string">    "domain": "www.cnblogs.com"</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="interview" scheme="http://huangkun.host/categories/interview/"/>
    
    
      <category term="vue" scheme="http://huangkun.host/tags/vue/"/>
    
      <category term="interview" scheme="http://huangkun.host/tags/interview/"/>
    
  </entry>
  
  <entry>
    <title>highlightjs在vue中使用的坑</title>
    <link href="http://huangkun.host/2020/03/25/20190820-highlightjs%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/"/>
    <id>http://huangkun.host/2020/03/25/20190820-highlightjs%E5%9C%A8vue%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E5%9D%91/</id>
    <published>2020-03-25T07:36:28.419Z</published>
    <updated>2020-03-25T08:22:35.476Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="highlight-js"><a href="#highlight-js" class="headerlink" title="highlight.js"></a>highlight.js</h3><p>之前在弄博客的代码高亮的时候, 使用的是highlight.js这个插件, 当时用的挺好</p><p>最近换了一个博客系统, 使用的是 Vue 框架, 但是 highlight.js 这个插件在 Vue 中使用会有一个坑</p><p>根据官方文档中说的 在页面引入:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/path/to/highlight.pack.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span>hljs.initHighlightingOnLoad();<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这种引入是在首页的加载完成后就初始化 highlight.js.</p><p>而我在博客中, 是在文章页面才需要 初始化 highlight.js, 不需要在首页进行初始化(因为首页没有代码块), 所以我使用了 initHighlighting 方法.</p><p>然后我就遇到了一个奇怪的问题, 只有在刷新后第一次进入文章页的时候, 代码高亮能正常显示, 第二次, 返回首页后再点击文章进入 页面代码高亮功能就不正常了.</p><p>遂去查询解决办法, 花了几个小时, 发现网上说的情况对我来说都不怎么适用, 当时有几篇文章给了我一些思路, 说: vue-router 在路由进行切换的时候 会调用 initHighlighting 方法, 此方法有一段逻辑是判断之前是否被调用过, 如果被调用过, 直接 return, (我判断是因为浏览器的后退事件触发的时候, highlight.js 的实例没有销毁), 所以再次调用的时候, 直接return掉了.</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>直接修改 highlight.js 源码的 initHighlighting 方法:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initHighlighting</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initHighlighting.called)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  initHighlighting.called = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> blocks = <span class="built_in">document</span>.querySelectorAll(<span class="string">'pre code'</span>);</span><br><span class="line">  ArrayProto.forEach.call(blocks, highlightBlock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if (initHighlighting.called) return; 这行注释掉, 直接执行后面的代码即可.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="javascript" scheme="http://huangkun.host/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://huangkun.host/tags/javascript/"/>
    
      <category term="vue" scheme="http://huangkun.host/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>vue首屏加载速度优化</title>
    <link href="http://huangkun.host/2020/03/25/20190812-vue%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/"/>
    <id>http://huangkun.host/2020/03/25/20190812-vue%E9%A6%96%E5%B1%8F%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E4%BC%98%E5%8C%96/</id>
    <published>2020-03-25T07:36:28.418Z</published>
    <updated>2020-03-25T08:22:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>后台管理型项目就是页面多, 当页面多的时候, 首屏加载的静态资源(css/js文件)就会很多, 我们项目就在被客户投诉说首页加载速度太慢, 遂排查是什么原因, 到底是前端的问题还是后台的问题(判断后台的问题可以参考我的另一片文章TTFB时间过长)</p><p>初始加载的时候, 一共请求了195个资源, 传送了18.1M的数据, 一共用了3.3s 才加载完成, 经分析, 其中大部分是js文件</p><p><img src="/" alt="request" class="lazyload" data-src="../../assets/images/request.png"></p><p>遂去网上寻找优化之道, 找到几种优化的思路</p><ol><li>vue-router路由懒加载</li><li>去除首页不必要的依赖(去除组件的全局引入)</li><li>手动引入模块库的方法</li><li>使用更轻量的工具库</li><li>CDN优化</li><li>nginx开启gzip</li><li>…</li></ol><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="1-vue-router路由懒加载"><a href="#1-vue-router路由懒加载" class="headerlink" title="1. vue-router路由懒加载"></a>1. vue-router路由懒加载</h3><p><a href="https://router.vuejs.org/guide/advanced/lazy-loading.html" target="_blank" rel="noopener">官方文档</a>已经给出了对应的方法, 这里简单说说</p><p>vue 一共有三种方法实现按需加载</p><p>1.1. vue的异步组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* vue异步组件技术 */</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  name: <span class="string">'home'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'@/components/home'</span>], resolve),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/index'</span>,</span><br><span class="line">  name: <span class="string">'Index'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'@/components/index'</span>], resolve),</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/about'</span>,</span><br><span class="line">  name: <span class="string">'about'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">require</span>([<span class="string">'@/components/about'</span>], resolve),</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>1.2. es的提案import()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面3行代码，没有指定webpackChunkName，每个组件打包成一个js文件。</span></span><br><span class="line"><span class="keyword">const</span> Home = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/home'</span>)</span><br><span class="line"><span class="keyword">const</span> Index = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/index'</span>)</span><br><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'@/components/about'</span>)</span><br><span class="line"><span class="comment">// 下面3行代码，指定了相同的webpackChunkName，会合并打包成一个js文件。 把组件按组分块</span></span><br><span class="line"><span class="keyword">const</span> Home =  <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'ImportFuncDemo' */</span> <span class="string">'@/components/home'</span>)</span><br><span class="line"><span class="keyword">const</span> Index = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'ImportFuncDemo' */</span> <span class="string">'@/components/index'</span>)</span><br><span class="line"><span class="keyword">const</span> About = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="comment">/* webpackChunkName: 'ImportFuncDemo' */</span> <span class="string">'@/components/about'</span>)</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  name: <span class="string">'home'</span>,</span><br><span class="line">  component: Home,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/index'</span>,</span><br><span class="line">  name: <span class="string">'Index'</span>,</span><br><span class="line">  component: Index,</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/about'</span>,</span><br><span class="line">  name: <span class="string">'about'</span>,</span><br><span class="line">  component: About,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>注意: 官方文档有一次说明, 如果使用babel, 要安装一个 babel 的插件 <em>syntax-dynamic-import</em> 来让babel识别这个语法, 还有一个webpack 的配置, 在 output 中加个 chunkFilename</p><p>安装依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/plugin-syntax-dynamic-import</span><br></pre></td></tr></table></figure><p>并且在webpack的output中加入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunkFilename: <span class="string">'[name].js'</span></span><br></pre></td></tr></table></figure><p>1.3. webpack的 require, ensure()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 组件懒加载方案三: webpack提供的require.ensure() */</span></span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/home'</span>,</span><br><span class="line">  name: <span class="string">'home'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], () =&gt; r(<span class="built_in">require</span>(<span class="string">'@/components/home'</span>)), <span class="string">'demo'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/index'</span>,</span><br><span class="line">  name: <span class="string">'Index'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], () =&gt; r(<span class="built_in">require</span>(<span class="string">'@/components/index'</span>)), <span class="string">'demo'</span>)</span><br><span class="line">&#125;,</span><br><span class="line">&#123;</span><br><span class="line">  path: <span class="string">'/about'</span>,</span><br><span class="line">  name: <span class="string">'about'</span>,</span><br><span class="line">  component: <span class="function"><span class="params">r</span> =&gt;</span> <span class="built_in">require</span>.ensure([], () =&gt; r(<span class="built_in">require</span>(<span class="string">'@/components/about'</span>)), <span class="string">'demo-01'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目前最常用的是第二种方法</p><h3 id="2-去除不必要的依赖-去除组件的全局引入"><a href="#2-去除不必要的依赖-去除组件的全局引入" class="headerlink" title="2. 去除不必要的依赖(去除组件的全局引入)"></a>2. 去除不必要的依赖(去除组件的全局引入)</h3><p>大家看一看自己的 main.js 文件, 是不是有一些不需要注册在全局的组件, 但是为了方便省事, 而放在了全局, 如果发现使用的不多的, 可以去除全局的, 进行按需加载</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ImageComponent <span class="keyword">from</span> <span class="string">'COMMON/imageComponent'</span></span><br><span class="line"><span class="keyword">import</span> InfiniteLoading <span class="keyword">from</span> <span class="string">'COMMON/infiniteLoading'</span></span><br><span class="line"><span class="keyword">import</span> SearchDialog <span class="keyword">from</span> <span class="string">'COMMON/SearchDialog'</span></span><br><span class="line"><span class="keyword">import</span> BasicTable <span class="keyword">from</span> <span class="string">'COMMON/BasicTable'</span></span><br><span class="line"><span class="keyword">import</span> VueQriously <span class="keyword">from</span> <span class="string">'vue-qriously'</span></span><br><span class="line"></span><br><span class="line">Vue.use(ImageComponent)</span><br><span class="line">Vue.use(InfiniteLoading) <span class="comment">// 可以去除</span></span><br><span class="line">Vue.use(SearchDialog) <span class="comment">// 可以去除</span></span><br><span class="line">Vue.use(BasicTable)  <span class="comment">// 可以去除</span></span><br><span class="line">Vue.use(VueQriously)  <span class="comment">// 可以去除</span></span><br></pre></td></tr></table></figure><h3 id="3-手动引入模块库的方法"><a href="#3-手动引入模块库的方法" class="headerlink" title="3. 手动引入模块库的方法"></a>3. 手动引入模块库的方法</h3><p>默认引入 ECharts 是引入全部的import * as ECharts from ‘echarts’ 我们只需要部分组件，只需引入自己需要的部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> VueECharts <span class="keyword">from</span> <span class="string">'vue-echarts/components/ECharts.vue'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'echarts/lib/chart/line'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'echarts/lib/chart/bar'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'echarts/lib/chart/pie'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'echarts/lib/component/title'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'echarts/lib/component/tooltip'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'echarts/lib/component/legend'</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">'echarts/lib/component/markPoint'</span></span><br></pre></td></tr></table></figure><p>使用lodash尽量使用哪个方法 引入那个方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在组件文件中一般是这样引入的:</span></span><br><span class="line"><span class="keyword">import</span> _ <span class="keyword">from</span> <span class="string">'lodash'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是如果这个组件你只需要使用lodash其中的一个方法, 你可以这样引入</span></span><br><span class="line"><span class="keyword">import</span> cloneDeep <span class="keyword">from</span> <span class="string">'lodash/cloneDeep'</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">const</span> cloneDeep= <span class="built_in">require</span>(<span class="string">'lodash/cloneDeep'</span>);</span><br></pre></td></tr></table></figure><p>当然你如果文件中使用了较多的lodash方法的情况下, 不太美观, 且并不方便. 那么我们可以借助于lodash-webpack-plugin, 去除未引入的模块, 需要和babel-plugin-lodash插件配合使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1  安装插件</span></span><br><span class="line">npm i -S lodash-webpack-plugin babel-plugin-lodash</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2  修改 webpack.conf.js 文件</span></span><br><span class="line"><span class="keyword">const</span> LodashModuleReplacementPlugin = <span class="built_in">require</span>(<span class="string">'lodash-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line">plugins: [ <span class="keyword">new</span> LodashModuleReplacementPlugin()]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3  .bablerc中配置</span></span><br><span class="line"><span class="string">"plugins"</span>: [<span class="string">"transform-runtime"</span>,<span class="string">"transform-vue-jsx"</span>,<span class="string">"lodash"</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者在webpack.conf.js的rules配置</span></span><br><span class="line">&#123;</span><br><span class="line">  test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">  loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">  exclude: <span class="regexp">/node_modules/</span>,</span><br><span class="line">  include: [resolve(<span class="string">'src'</span>), resolve(<span class="string">'test'</span>)],</span><br><span class="line">  options: &#123;</span><br><span class="line">    plugins: [<span class="string">'lodash'</span>],</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-使用更轻量级的工具库"><a href="#4-使用更轻量级的工具库" class="headerlink" title="4. 使用更轻量级的工具库"></a>4. 使用更轻量级的工具库</h3><p>moment是处理时间的标杆，但是它过于庞大且默认不支持tree-shaking，而且我们的项目中只用到了moment(), format(), add(), subtract()等几个非常简单的方法，有点大材小用，所以我们用 date-fns 来替换它，需要什么方法直接引入就行。</p><h3 id="5-CDN优化"><a href="#5-CDN优化" class="headerlink" title="5. CDN优化"></a>5. CDN优化</h3><p>我们发现, Vue 全家桶以及 ElementUI 仍然占了很大一部分 vendors 体积，这部分代码是不变的，但会随着每次 vendors 打包改变 hash 重新加载。我们可以使用 CDN 剔除这部分不经常变化的公共库。我们将vue，vue-router，vuex，axios，jquery，underscore，使用CDN资源引入。国内的CDN服务推荐使用 BootCDN</p><p>首先我们要在 index.html 中, 添加 CDN 的相关代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"https://cdn.bootcss.com/element-ui/2.7.2/theme-chalk/index.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"app"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue/2.6.10/vue.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vuex/3.1.0/vuex.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/vue-router/3.0.4/vue-router.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/axios/0.18.0/axios.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/element-ui/2.7.2/index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/jquery/3.4.0/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.bootcss.com/underscore.js/1.9.1/underscore-min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 vue.config.js 中加入 webpack 配置代码，关于 webpack 配置中的 externals ，参考地址</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">configureWebpack: &#123;</span><br><span class="line">  externals: &#123;</span><br><span class="line">    <span class="string">'vue'</span>: <span class="string">'Vue'</span>, <span class="comment">// 左侧vue是我们自己引入时候要用的，右侧是开发依赖库的主人定义的不能修改</span></span><br><span class="line">    <span class="string">'vue-router'</span>: <span class="string">'VueRouter'</span>,</span><br><span class="line">    <span class="string">'vuex'</span>: <span class="string">'Vuex'</span>,</span><br><span class="line">    <span class="string">'element-ui'</span>: <span class="string">'ELEMENT'</span>,</span><br><span class="line">    <span class="string">'axios'</span>: <span class="string">'axios'</span>,</span><br><span class="line">    <span class="string">'underscore'</span> : &#123;</span><br><span class="line">      commonjs: <span class="string">'underscore'</span>,</span><br><span class="line">      amd: <span class="string">'underscore'</span>,</span><br><span class="line">      root: <span class="string">'_'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'jquery'</span>: &#123;</span><br><span class="line">      commonjs: <span class="string">'jQuery'</span>,</span><br><span class="line">      amd: <span class="string">'jQuery'</span>,</span><br><span class="line">      root: <span class="string">'$'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>去除 vue.use() 相关代码<br>需要注意的是，通过 CDN 引入，在使用 VueRouter Vuex ElementUI 的时候要改下写法。CDN会把它们挂载到window上，因此不再使用Vue.use(xxx)</p><p>也不在需import Vue from ‘vue’, import VueRouter from ‘vue-router’ 等。</p><p>剔除全家桶和Element-ui等只有，剩下的需要首次加载 vendors 就很小了。</p><p>使用 CDN 的好处有以下几个方面</p><p>（1）加快打包速度。分离公共库以后，每次重新打包就不会再把这些打包进 vendors 文件中。</p><p>（2）CDN减轻自己服务器的访问压力，并且能实现资源的并行下载。浏览器对 src 资源的加载是并行的(执行是按照顺序的)。</p><h3 id="6-检查-Nginx-是否开启-gzip"><a href="#6-检查-Nginx-是否开启-gzip" class="headerlink" title="6. 检查 Nginx 是否开启 gzip"></a>6. 检查 Nginx 是否开启 gzip</h3><p>如下图所示，开启了 gzip 后 js 的大小比未开启 gzip 的 js 小 2/3 左右，所以如果没开启 gzip ，感觉我们做的再多意义也不大，如何看自己的项目有没有开启 gzip，如下图所示，开启了 gzip，在浏览器的控制台 Content-Encoding 一栏会显示gzip，否则没有。 Nginx 如果开启 gzip，请自行搜索，或者叫服务端来开启。</p><p><img src="/" alt="webpack" class="lazyload" data-src="../../assets/images/shell-webpack.png"><br><img src="/" alt="chorme" class="lazyload" data-src="../../assets/images/chrome_gzip.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="vue" scheme="http://huangkun.host/categories/vue/"/>
    
    
      <category term="vue" scheme="http://huangkun.host/tags/vue/"/>
    
      <category term="前端性能优化" scheme="http://huangkun.host/tags/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Nodejs的Stream</title>
    <link href="http://huangkun.host/2020/03/25/20190725-Nodejs%E7%9A%84Stream/"/>
    <id>http://huangkun.host/2020/03/25/20190725-Nodejs%E7%9A%84Stream/</id>
    <published>2020-03-25T07:36:28.417Z</published>
    <updated>2020-03-25T08:22:49.032Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="流"><a href="#流" class="headerlink" title="流"></a>流</h2><ul><li>流是一组有序的，有起点和终点的字节数据传输手段。</li><li>它不关心文件的整体内容，只关注是否从文件中读到了数据，以及读到数据之后的处理。</li><li>流是一个抽象接口，被 Node 中的很多对象所实现。比如HTTP 服务器request和response对象都是流。</li><li>流被分为 Readable(可读流)、 Writable(可写流)、 Duplex(双工流)、 Transform(转换流)</li></ul><h2 id="流中的是什么"><a href="#流中的是什么" class="headerlink" title="流中的是什么"></a>流中的是什么</h2><ul><li><em>二进制模式</em>：每个分块都是buffer、string对象。</li><li><em>对象模式</em>：流内部处理的是一系列普通对象。</li></ul><h2 id="可读流"><a href="#可读流" class="headerlink" title="可读流"></a>可读流</h2><blockquote><p>可读流分为flowing和paused两种模式</p></blockquote><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ul><li>path：读取的文件的路径</li><li>option：<ul><li>highWaterMark：水位线，一次可读的字节，一般默认是64k</li><li>flags：标识，打开文件要做的操作，默认是r</li><li>encoding：编码，默认为buffer</li><li>start：开始读取的索引位置</li><li>end：结束读取的索引位置(包括结束位置)</li><li>autoClose：读取完毕是否关闭，默认为true</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ReadStream = <span class="built_in">require</span>(<span class="string">'./ReadStream'</span>)</span><br><span class="line"><span class="comment">//读取的时候默认读64k </span></span><br><span class="line"><span class="keyword">let</span> rs = <span class="keyword">new</span> ReadStream(<span class="string">'./a.txt'</span>,&#123;</span><br><span class="line">  highWaterMark: <span class="number">2</span>,<span class="comment">//一次读的字节 默认64k</span></span><br><span class="line">  flags: <span class="string">'r'</span>,      <span class="comment">//标示 r为读 w为写</span></span><br><span class="line">  autoClose: <span class="literal">true</span>, <span class="comment">//默认读取完毕后自动关闭</span></span><br><span class="line">  start: <span class="number">0</span>,</span><br><span class="line">  end: <span class="number">5</span>,          <span class="comment">//流是闭合区间包start，也包end 默认是读完</span></span><br><span class="line">  encoding: <span class="string">'utf8'</span> <span class="comment">//默认编码是buffer</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>data：切换到流动模式，可以流出数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>open：流打开文件的时候会触发此监听</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs.on(<span class="string">'open'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'文件被打开'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>error：流出错的时候，监听错误信息</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs.on(<span class="string">'error'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>end：流读取完成，触发end</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs.on(<span class="string">'end'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'读取完成'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>close：关闭流，触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rs.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'关闭'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>pause：暂停流(改变流的flowing，不读取数据了)；resume:恢复流(改变流的flowing,继续读取数据)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//流通过一次后，停止流动，过了2s后再动</span></span><br><span class="line">rs.on(<span class="string">'data'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    rs.pause();</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    rs.resume();</span><br><span class="line">&#125;,<span class="number">2000</span>);</span><br></pre></td></tr></table></figure><p>fs.read()：可读流底层调用的就是这个方法，最原生的读方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fd文件描述符，一般通过fs.open中获取</span></span><br><span class="line"><span class="comment">//buffer是读取后的数据放入的缓存目标</span></span><br><span class="line"><span class="comment">//0，从buffer的0位置开始放入</span></span><br><span class="line"><span class="comment">//BUFFER_SIZE，每次放BUFFER_SIZE这么长的长度</span></span><br><span class="line"><span class="comment">//index，每次从文件的index的位置开始读</span></span><br><span class="line"><span class="comment">//bytesRead，真实读到的个数</span></span><br><span class="line">fs.read(fd,buffer,<span class="number">0</span>,BUFFER_SIZE,index,<span class="function"><span class="keyword">function</span>(<span class="params">err,bytesRead</span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="node" scheme="http://huangkun.host/categories/node/"/>
    
    
      <category term="node" scheme="http://huangkun.host/tags/node/"/>
    
      <category term="javascript" scheme="http://huangkun.host/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>面试题</title>
    <link href="http://huangkun.host/2020/03/25/20190603-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>http://huangkun.host/2020/03/25/20190603-%E9%9D%A2%E8%AF%95%E9%A2%98/</id>
    <published>2020-03-25T07:36:28.416Z</published>
    <updated>2020-03-25T08:22:53.059Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="记录一些看过的而且答错了的面试题"><a href="#记录一些看过的而且答错了的面试题" class="headerlink" title="记录一些看过的而且答错了的面试题"></a>记录一些看过的而且答错了的面试题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shape = &#123;</span><br><span class="line">  radius: <span class="number">10</span>,</span><br><span class="line">  diameter() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.radius * <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">  perimeter: <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * <span class="keyword">this</span>.radius</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shape.diameter()</span><br><span class="line">shape.perimeter()</span><br></pre></td></tr></table></figure><p>注意 diameter 的值是一个常规函数，但是 perimeter 的值是一个箭头函数。</p><p>对于箭头函数，this 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。这意味着当我们调用 perimeter 时，this 不是指向 shape 对象，而是它的周围作用域（在例子中是 window）。</p><p>在 window 中没有 radius 这个属性，因此返回 undefined。</p><hr /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Chameleon</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> colorChange(newColor) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newColor = newColor</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.newColor</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span>(&#123; newColor = <span class="string">'green'</span> &#125; = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">this</span>.newColor = newColor</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> freddie = <span class="keyword">new</span> Chameleon(&#123; <span class="attr">newColor</span>: <span class="string">'purple'</span> &#125;)</span><br><span class="line">freddie.colorChange(<span class="string">'orange'</span>)</span><br></pre></td></tr></table></figure><p>colorChange 是一个静态方法。静态方法被设计为只能被创建它们的构造器使用（也就是 Chameleon），并且不能传递给实例。因为 freddie 是一个实例，静态方法不能被实例使用，因此抛出了 TypeError 错误。</p><hr /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">firstName, lastName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.firstName = firstName;</span><br><span class="line">  <span class="keyword">this</span>.lastName = lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> member = <span class="keyword">new</span> Person(<span class="string">"Lydia"</span>, <span class="string">"Hallie"</span>);</span><br><span class="line">Person.getFullName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(member.getFullName());</span><br></pre></td></tr></table></figure><p>你不能像常规对象那样，给构造函数添加属性。如果你想一次性给所有实例添加特性，你应该使用原型。因此本例中，使用如下方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.getFullName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.firstName&#125;</span> <span class="subst">$&#123;<span class="keyword">this</span>.lastName&#125;</span>`</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这才会使 member.getFullName() 起作用。为什么这么做有益的？假设我们将这个方法添加到构造函数本身里。也许不是每个 Person 实例都需要这个方法。这将浪费大量内存空间，因为它们仍然具有该属性，这将占用每个实例的内存空间。相反，如果我们只将它添加到原型中，那么它只存在于内存中的一个位置，但是所有实例都可以访问它！</p><hr /><p>事件冒泡的三个阶段是什么？ A: Target &gt; Capturing &gt; Bubbling B: Bubbling &gt; Target &gt; Capturing C: Target &gt; Bubbling &gt; Capturing D: Capturing &gt; Target &gt; Bubbling</p><p>在捕获（capturing）阶段中，事件从祖先元素向下传播到目标元素。当事件达到目标（target）元素后，冒泡（bubbling）才开始。</p><hr /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> number = <span class="number">0</span></span><br><span class="line"><span class="built_in">console</span>.log(number++)</span><br><span class="line"><span class="built_in">console</span>.log(++number)</span><br><span class="line"><span class="built_in">console</span>.log(number)</span><br></pre></td></tr></table></figure><p>一元后自增运算符 ++：</p><p>返回值（返回 0） 值自增（number 现在是 1） 一元前自增运算符 ++：</p><p>值自增（number 现在是 2） 返回值（返回 2）</p><hr /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="built_in">eval</span>(<span class="string">'10*10+5'</span>);</span><br></pre></td></tr></table></figure><p>代码以字符串形式传递进来，eval 对其求值。如果它是一个表达式，就像本例中那样，它对表达式求值。表达式是 10 * 10 + 5。这将返回数字 105。</p><hr /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> b = &#123; <span class="attr">key</span>: <span class="string">'b'</span> &#125;</span><br><span class="line"><span class="keyword">const</span> c = &#123; <span class="attr">key</span>: <span class="string">'c'</span> &#125;</span><br><span class="line"></span><br><span class="line">a[b] = <span class="number">123</span></span><br><span class="line">a[c] = <span class="number">456</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a[b])</span><br></pre></td></tr></table></figure><p>对象的键被自动转换为字符串。我们试图将一个对象 b 设置为对象 a 的键，且相应的值为 123。</p><p>然而，当字符串化一个对象时，它会变成 “[Object object]”。因此这里说的是，a[“Object object”] = 123。然后，我们再一次做了同样的事情，c 是另外一个对象，这里也有隐式字符串化，于是，a[“Object object”] = 456。</p><p>然后，我们打印 a[b]，也就是 a[“Object object”]。之前刚设置为 456，因此返回的是 456。</p><hr /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: <span class="string">'Lydia'</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.name&#125;</span> is <span class="subst">$&#123;age&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHi.call(person, <span class="number">21</span>)</span><br><span class="line">sayHi.bind(person, <span class="number">21</span>)</span><br></pre></td></tr></table></figure><p>Lydia is 21 function</p><p>使用这两种方法，我们都可以传递我们希望 this 关键字引用的对象。但是，.call 是立即执行的。</p><p>.bind 返回函数的副本，但带有绑定上下文！它不是立即执行的。</p><hr /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">下面哪些值是 falsy?</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">0</span>)</span><br><span class="line">;(<span class="string">''</span>)</span><br><span class="line">;(<span class="string">' '</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="literal">false</span>)</span><br><span class="line"><span class="literal">undefined</span></span><br></pre></td></tr></table></figure><p>只有 6 种 falsy 值:</p><p>undefined null NaN 0 ‘’ (empty string) false</p><p>Function 构造函数, 比如 new Number 和 new Boolean，是 truthy。</p><hr /><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">;<span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> x, y</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  &#125; <span class="keyword">catch</span> (x) &#123;</span><br><span class="line">    ;(x = <span class="number">1</span>), (y = <span class="number">2</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">  <span class="built_in">console</span>.log(y)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><p>catch 代码块接收参数 x。当我们传递参数时，这与之前定义的变量 x 不同 。这个 x 是属于 catch 块级作用域的。</p><p>然后，我们将块级作用域中的变量赋值为 1，同时也设置了变量 y 的值。现在，我们打印块级作用域中的变量 x，值为 1。</p><p>catch 块之外的变量 x 的值仍为 undefined， y 的值为 2。当我们在 catch 块之外执行 console.log(x) 时，返回 undefined，y 返回 2。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla
      
    
    </summary>
    
    
      <category term="interview" scheme="http://huangkun.host/categories/interview/"/>
    
    
      <category term="javascript" scheme="http://huangkun.host/tags/javascript/"/>
    
      <category term="interview" scheme="http://huangkun.host/tags/interview/"/>
    
  </entry>
  
</feed>
