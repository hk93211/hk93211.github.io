                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                [{"title":"面试题","date":"2019-06-03T06:21:09.000Z","url":"/2019/06/03/面试题/","tags":["interview"],"categories":["interview"],"content":"注意 diameter 的值是一个常规函数，但是 perimeter 的值是一个箭头函数。对于箭头函数，this 关键字指向的是它当前周围作用域（简单来说是包含箭头函数的常规函数，如果没有常规函数的话就是全局对象），这个行为和常规函数不同。这意味着当我们调用 perimeter 时，this 不是指向 shape 对象，而是它的周围作用域（在例子中是 window）。在 window 中没有 radius 这个属性，因此返回 undefined。colorChange 是一个静态方法。静态方法被设计为只能被创建它们的构造器使用（也就是 Chameleon），并且不能传递给实例。因为 freddie 是一个实例，静态方法不能被实例使用，因此抛出了 TypeError 错误。你不能像常规对象那样，给构造函数添加属性。如果你想一次性给所有实例添加特性，你应该使用原型。因此本例中，使用如下方式：这才会使 member.getFullName() 起作用。为什么这么做有益的？假设我们将这个方法添加到构造函数本身里。也许不是每个 Person 实例都需要这个方法。这将浪费大量内存空间，因为它们仍然具有该属性，这将占用每个实例的内存空间。相反，如果我们只将它添加到原型中，那么它只存在于内存中的一个位置，但是所有实例都可以访问它！事件冒泡的三个阶段是什么？A: Target &gt; Capturing &gt; BubblingB: Bubbling &gt; Target &gt; CapturingC: Target &gt; Bubbling &gt; CapturingD: Capturing &gt; Target &gt; Bubbling在捕获（capturing）阶段中，事件从祖先元素向下传播到目标元素。当事件达到目标（target）元素后，冒泡（bubbling）才开始。一元后自增运算符 ++：返回值（返回 0）值自增（number 现在是 1）一元前自增运算符 ++：值自增（number 现在是 2）返回值（返回 2）代码以字符串形式传递进来，eval 对其求值。如果它是一个表达式，就像本例中那样，它对表达式求值。表达式是 10 * 10 + 5。这将返回数字 105。对象的键被自动转换为字符串。我们试图将一个对象 b 设置为对象 a 的键，且相应的值为 123。然而，当字符串化一个对象时，它会变成 “[Object object]”。因此这里说的是，a[“Object object”] = 123。然后，我们再一次做了同样的事情，c 是另外一个对象，这里也有隐式字符串化，于是，a[“Object object”] = 456。然后，我们打印 a[b]，也就是 a[“Object object”]。之前刚设置为 456，因此返回的是 456。Lydia is 21function使用这两种方法，我们都可以传递我们希望 this 关键字引用的对象。但是，.call 是立即执行的。.bind 返回函数的副本，但带有绑定上下文！它不是立即执行的。只有 6 种 falsy 值:undefinednullNaN0‘’ (empty string)falseFunction 构造函数, 比如 new Number 和 new Boolean，是 truthy。catch 代码块接收参数 x。当我们传递参数时，这与之前定义的变量 x 不同 。这个 x 是属于 catch 块级作用域的。然后，我们将块级作用域中的变量赋值为 1，同时也设置了变量 y 的值。现在，我们打印块级作用域中的变量 x，值为 1。catch 块之外的变量 x 的值仍为 undefined， y 的值为 2。当我们在 catch 块之外执行 console.log(x) 时，返回 undefined，y 返回 2。"},{"title":"http基础知识","date":"2019-05-16T08:51:09.000Z","url":"/2019/05/16/http基础知识/","tags":["http"],"categories":["http"],"content":"WWW (World Wide Web): 万维网HTTP (HyperText Transfer Protocol): 超文本传输协议HTML (HyperText Markup Language): 超文本标记语言URL (Uniform Resource Locatior): 统一资源定位符FTP (File Transfer Protocol): 文件传输协议DNS (Domain Name System): 域名系统TCP (Transmission Control Protocol): 传输控制协议UDP (User Data Protocol): 用户数据协议IP (Internet Protocol): 网络协议MAC (Media Access Control Address): 媒体访问控制地址，也称为局域网地址 (LAN Address) ，以太网地址 (Ethernet Address) 或物理地址 (Physical Address)LAN (Local Area Network): 局域网three-way handshaking: 三次握手SYN (Synchronize/Synchronize Sequence Numbers): 同步序列编号 =&gt; 三次握手第一, 第二次发送ACK (Acknowledgement): 应答 =&gt; 三次握手第二, 第三次发送"},{"title":"Express结合webpack实现HMR","date":"2019-05-14T01:04:13.000Z","url":"/2019/05/14/Express结合webpack实现HMR/","tags":["webpack"],"categories":["webpack"],"content":"webpack dev serverWebpack dev server 是一个轻量的node.js express服务器，实现了 webpack 编译代码实时输出更新。在前后端分离的前端项目开发中经常用到。webpack-dev-middlewareWebpack dev middleware 是 WebPack 的一个中间件。它用于在 Express 中分发需要通过 WebPack 编译的文件。单独使用它就可以完成代码的热重载（hot reloading）功能。特性：不会在硬盘中写入文件，完全基于内存实现。如果使用 watch 模式监听代码修改，Webpack 会自动编译，如果在 Webpack 编译过程中请求文件，Webpack dev middleware 会延迟请求，直到编译完成之后再开始发送编译完成的文件。webpack-hot-middlewareWebpack hot middleware 是 WebPack 的一个中间件, 它通过订阅 Webpack 的编译更新，之后通过执行 webpack 的 HMR api 将这些代码模块的更新推送给浏览器端。HMRHMR 即 Hot Module Replacement 是 Webpack 一个重要的功能。它可以使我们不用通过手动地刷新浏览器页面实现将我们的更新代码实时应用到当前页面中。HMR 的实现原理是在我们的开发中的应用代码中加入了 HMR Runtime，它是 HMR 的客户端（浏览器端 client）用于和开发服务器通信，接收更新的模块。服务端工作就是前面提到的 Webpack hot middleware 的，它会在代码更新编译完成之后通过以 json 格式输出给HMR Runtime 就会更具 json 中描述来动态更新相应的代码。webpack 配置先在webpack配置文件中引入在我们的开发环境中是这样配置的。getEntries 是自动根据我们规则获取到入口文件并加上 webpack hot middle 配置。Express 中的配置在 Express 的配置主要就4个步骤：引入 webpack 的配置文件和 生成 webpack 的编译器将编译器连接至 webpack dev middleware将编译器连接至 webpack hot middleware定义 express 配置要注意的是一定要在定义 express router 前定义 webpack 相关的中间件。还有一点是这里server.js 只是开发环境中使用，在生产环境中我们就不需要再用到它们了。所以在我们实际的使用中需要通过定义环境变量来区分开发和生产环境"},{"title":"http和https","date":"2019-05-13T07:06:09.000Z","url":"/2019/05/13/http和https/","tags":["http"],"categories":["http"],"content":"前言最近, 个人博客想加上小绿锁, 也就是安全连接的标识, 但是自己的http相关知识太匮乏了, 所以想去了解一下 http 的相关知识所以带着一下几个问题去查资料:HTTP是什么HTTP通信存在什么问题HTTPS如何改进HTTP存在那些问题HTTPS工作原理是什么HTTP是什么HTTP协议(HyperText Transfer Protocol，超文本传输协议) 是因特网上应用最为广泛的一种网络传输协议, 所有的WWW文件都必须遵守这个标准.HTTP是一个基于TCP/IP通信协议来传递数据(HTML 文件, 图片文件, 查询结果等)HTTPS是什么HTTPS是在HTTP上建立SSL加密层，并对传输数据进行加密，是HTTP协议的安全版。现在它被广泛用于万维网上安全敏感的通讯，例如交易支付方面。HTTPS主要作用是：（1）对数据进行加密，并建立一个信息安全通道，来保证传输过程中的数据安全;（2）对网站服务器进行真实身份认证。我们经常会在Web的登录页面和购物结算界面等使用HTTPS通信。使用HTTPS通信时，不再用 http://，而是改用 https://。另外，当浏览器访问HTTPS通信有效的Web网站时，浏览器的地址栏内会出现一个带锁的标记。对HTTPS的显示方式会因浏览器的不同而有所改变。HTTP协议存在的哪些问题使用明文通讯由于HTTP本身不具备加密的功能，所以也无法做到对通信整体（使用HTTP协议通信的请求和响应的内容）进行加密。即，HTTP报文使用明文（指未经过加密的报文）方式发送, 内容有可能被窃听。HTTP明文协议的缺陷是导致数据泄露、数据篡改、流量劫持、钓鱼攻击等安全问题的重要原因。HTTP协议无法加密数据，所有通信数据都在网络中明文“裸奔”。通过网络的嗅探设备及一些技术手段，就可还原HTTP报文内容。无法证明报文的完整性所谓完整性是指信息的准确度。若无法证明其完整性，通常也就意味着无法判断信息是否准确。由于HTTP协议无法证明通信的报文完整性，因此，在请求或响应送出之后直到对方接收之前的这段时间内，即使请求或响应的内容遭到篡改，也没有办法获悉。换句话说，没有任何办法确认，发出的请求/响应和接收到的请求/响应是前后相同的(所以可能遭篡改)。不验证通信方的身份HTTP协议中的请求和响应不会对通信方进行确认(因此可能遭遇伪装)。在HTTP协议通信时，由于不存在确认通信方的处理步骤，任何人都可以发起请求。另外，服务器只要接收到请求，不管对方是谁都会返回一个响应（但也仅限于发送端的IP地址和端口号没有被Web服务器设定限制访问的前提下）HTTP协议无法验证通信方身份，任何人都可以伪造虚假服务器欺骗用户，实现“钓鱼欺诈”，用户无法察觉。反观HTTPS协议，它比HTTP协议相比多了以下优势（下文会详细介绍）:数据隐私性：内容经过对称加密，每个连接生成一个唯一的加密密钥数据完整性：内容传输经过完整性校验身份认证：第三方无法伪造服务端（客户端）身份HTTPS如何解决HTTP上述问题HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL和TLS协议代替而已。通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由SSL和TCP通信了。简言之，所谓HTTPS，其实就是身披SSL协议这层外壳的HTTP。在采用SSL后，HTTP就拥有了HTTPS的加密、证书和完整性保护这些功能。也就是说HTTP加上加密处理和认证以及完整性保护后即是HTTPS。HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数 、对称加密和非对称加密，其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。HTTPS工作流程1.Client发起一个HTTPS (比如 ) 的请求，根据RFC2818的规定，Client知道需要连接Server的443（默认）端口。2.Server把事先配置好的公钥证书（public key certificate）返回给客户端。3.Client验证公钥证书：比如是否在有效期内，证书的用途是不是匹配Client请求的站点，是不是在CRL吊销列表里面，它的上一级证书是否有效，这是一个递归的过程，直到验证到根证书（操作系统内置的Root证书或者Client内置的Root证书）。如果验证通过则继续，不通过则显示警告信息。4.Client使用伪随机数生成器生成加密所使用的对称密钥，然后用证书的公钥加密这个对称密钥，发给Server。5.Server使用自己的私钥（private key）解密这个消息，得到对称密钥。至此，Client和Server双方都持有了相同的对称密钥。6.Server使用对称密钥加密“明文内容A”，发送给Client。7.Client使用对称密钥解密响应的密文，得到“明文内容A”。8.Client再次发起HTTPS的请求，使用对称密钥加密请求的“明文内容B”，然后Server使用对称密钥解密密文，得到“明文内容B”。HTTP 和 HTTPS 的区别HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。关于安全性，用最简单的比喻形容两者的关系就是卡车运货，HTTP下的运货车是敞篷的，货物都是暴露的。而https则是封闭集装箱车，安全性自然提升不少。HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页;HTTPS需要用到SSL证书，而HTTP不用;HTTPS标准端口443，HTTP标准端口80;HTTPS基于传输层，HTTP基于应用层;HTTPS在浏览器显示绿色安全锁，HTTP没有显示;为何不所有的网站都使用HTTPS首先，很多人还是会觉得HTTPS实施有门槛，这个门槛在于需要权威CA颁发的SSL证书。从证书的选择、购买到部署，传统的模式下都会比较耗时耗力。其次，HTTPS普遍认为性能消耗要大于HTTP，因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。如果每次通信都加密，会消耗相当多的资源，平摊到一台计算机上时，能够处理的请求数量必定也会随之减少。但事实并非如此，用户可以通过性能优化、把证书部署在SLB或CDN，来解决此问题。举个实际的例子，“双十一”期间，全站HTTPS的淘宝、天猫依然保证了网站和移动端的访问、浏览、交易等操作的顺畅、平滑。通过测试发现，经过优化后的许多页面性能与HTTP持平甚至还有小幅提升，因此HTTPS经过优化之后其实并不慢。除此之外，想要节约购买证书的开销也是原因之一。要进行HTTPS通信，证书是必不可少的。而使用的证书必须向认证机构（CA）购买。最后是安全意识。相比国内，国外互联网行业的安全意识和技术应用相对成熟，HTTPS部署趋势是由社会、企业、政府共同去推动的。"},{"title":"webpack的plugin","date":"2019-05-09T07:25:09.000Z","url":"/2019/05/09/webpack一些plugin/","tags":["webpack"],"categories":["webpack"],"content":"generate-json-webpack-plugin最近在接触一个新的vue项目的时候, 发现项目初始化的时候回去请求一个json配置文件,但是我在开发本地目录找不到对应的 json 配置, 只有几个内容相似的 js 文件, 遂想是否是 webpack 将 js 文件转换成了 json 文件了, 就去看 webpack 配置文件, 发现一个叫 generate-json-webpack-plugin 的插件: 这将会在 webpack 输出目录创建一个名为: my-file.json 的文件, 内容为:generate-json-webpack-plugin 插件还能接收第3和第4个参数, 分别为”要替换的内容” 和 “空格个数” 功能:此时 my-file.json 文件的内容为:webpack-dev-middlewareWebpack dev middleware 是 WebPack 的一个中间件。它用于在 Express 中分发需要通过 WebPack 编译的文件。单独使用它就可以完成代码的热重载（hot reloading）功能。特性：不会在硬盘中写入文件，完全基于内存实现。如果使用 watch 模式监听代码修改，Webpack 会自动编译，如果在 Webpack 编译过程中请求文件，Webpack dev middleware 会延迟请求，直到编译完成之后再开始发送编译完成的文件。webpack-hot-middlewareWebpack hot middleware 它通过订阅 Webpack 的编译更新，之后通过执行 webpack 的 HMR api 将这些代码模块的更新推送给浏览器端。"},{"title":"nginx基础知识","date":"2019-04-19T09:43:12.000Z","url":"/2019/04/19/nginx/","tags":["nginx"],"categories":["nginx"],"content":"nginx在应用程序中的作用解决跨域请求过滤配置gzip负载均衡静态资源服务器首先先来了解一下一些基础知识， nginx是一个高性能的反向代理服务器那么什么是反向代理呢？正向代理与反向代理代理是在服务器和客户端之间假设的一层服务器，代理将接收客户端的请求并将它转发给服务器，然后将服务端的响应转发给客户端。不管是正向代理还是反向代理，实现的都是上面的功能。正向代理正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。正向代理是为我们服务的，即为客户端服务的，客户端可以根据正向代理访问到它本身无法访问到的服务器资源。正向代理对我们是透明的，对服务端是非透明的，即服务端并不知道自己收到的是来自代理的访问还是来自真实客户端的访问。反向代理反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。反向代理是为服务端服务的，反向代理可以帮助服务器接收来自客户端的请求，帮助服务器做请求转发，负载均衡等。反向代理对服务端是透明的，对我们是非透明的，即我们并不知道自己访问的是代理服务器，而服务器知道反向代理在为他服务。main:nginx的全局配置，对全局生效。events:配置影响nginx服务器或与用户的网络连接。http：可以嵌套多个server，配置代理，缓存，日志定义等绝大多数功能和第三方模块的配置。server：配置虚拟主机的相关参数，一个http中可以有多个server。location：配置请求的路由，以及各种页面的处理情况。upstream：配置后端服务器具体地址，负载均衡配置不可或缺的部分。内置变量下面是 nginx一些配置中常用的内置全局变量，你可以在配置的任何位置使用它们。变量名功能$host请求信息中的 Host，如果请求中没有 Host行，则等于设置的服务器名$request_method客户端请求类型，如 GET、 POST$remote_addr客户端的 IP地址$args请求中的参数$content_length请求头中的 Content-length字段$http_user_agent客户端agent信息$http_cookie客户端cookie信息$remote_addr客户端的IP地址$remote_port客户端的端口$server_protocol请求使用的协议，如 HTTP/1.0、·HTTP/1.1`$server_addr服务器地址$server_name服务器名称$server_port服务器的端口号nginx解决跨域的原理例如：前端server的域名为：fe.server.com后端服务的域名为：dev.server.com现在我在 fe.server.com 对 dev.server.com 发起请求一定会出现跨域。现在我们只需要启动一个nginx服务器，将 server_name设置为 fe.server.com,然后设置相应的location以拦截前端需要跨域的请求，最后将请求代理回 dev.server.com。如下面的配置：这样可以完美绕过浏览器的同源策略： fe.server.com 访问 nginx 的 fe.server.com 属于同源访问，而 nginx对服务端转发的请求不会触发浏览器的同源策略。请求过滤根据状态码过滤根据URL名称过滤，精准匹配URL，不匹配的URL全部重定向到主页。根据请求类型过滤。配置gzip负载均衡什么是负载均衡打个比方, 车站排队买票, 有很多个窗口, 每个窗口都排这很多人在等着买票, 人们会自己判断走到人少的队伍后面排着等着买票, 但是机器不会将来的人分到哪一个队伍下面去排队, 下面有很多用户需要服务，我们需要一个工具或策略来帮助我们将如此多的用户分配到每个窗口，来达到资源的充分利用以及更少的排队时间。把前面的服务窗口想像成我们的后端服务器，而后面终端的人则是无数个客户端正在发起请求。负载均衡就是用来帮助我们将众多的客户端请求合理的分配到各个服务器，以达到服务端资源的充分利用和更少的请求时间。nginx如何实现负载均衡Upstream指定后端服务器地址列表:在server中拦截响应请求，并将请求转发到Upstream中配置的服务器列表。上面的配置只是指定了nginx需要转发的服务端列表，并没有指定分配策略。参考前端开发者必备的 Nginx 知识"},{"title":"Waiting (TTFB) 时间过长","date":"2019-02-21T14:13:12.000Z","url":"/2019/02/21/TTFB时间过长/","tags":["javascript"],"categories":["javascript"],"content":"背景最近项目中的某个页面的加载时间过长, 从第一个接口开始到最后一个接口调用结束一共用了 5.5s ~ 6s.通过浏览器调试工具的 Network 页签, 仔细查看每一个接口的调用时间, 抛开调用后端的resful接口, 静态资源(.js/.html/.json)的加载及解析花了大量的时间.查看这些静态资源的请求的Waterfall, 发现有的接口的 Waiting (TTFB) 选项时长过长, 有的接口的 Content Download 时间过长.什么是 Waiting (TTFB) 时间什么是 Waiting (TTFB) 时间, TTFB 是 Time to First Byte 的缩写，指的是浏览器开始收到服务器响应数据的时间  (后台处理时间+重定向时间) ，是反映服务端响应速度的重要指标。就像你问朋友了一个问题，你的朋友思考了一会儿才给你答案，你朋友思考的时间就相当于 TTFB。你朋友思考的时间越短，就说明你朋友越聪明或者对你的问题越熟悉。对服务器来说，TTFB 时间越短，就说明服务器响应越快。TTFB 时间多长算长？因为每个服务器的硬件和网络环境都不尽相同，每个服务器的 TTFB 时间也不相同。如果想知道你的服务器可以优化到什么程度，大家可以上传一些静态的 HTML 页面到服务器，然后打开这些静态页面，看一些这些页面的 TTFB 时间，大多数服务器的 TTFB 时间都在 50 ms 一下，这个时间就是我们优化时候可以追求的时间。下面两个图中的 TTFB 时间分别是本站所在服务器的静态和动态网页 TTFB 等待时间。根据我们的测试，TTFB 时间如果超过了 500 ms，用户在打开网页的时候就会感觉到明显的等待。我么可以把 500 ms 以上认为是 TTFB 时间过长。TTFB 过长的原因我们知道，对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模版中，模版渲染后，再返回给用户。由于查询数据和渲染模版需要需要一定的时间，在这个过程没有完成之前，浏览器就一致处于等待接收服务器响应的状态。服务的性能比较低，或者优化没做好，这个时间就会比较长。服务器到用户之间的网络不好，（比如，服务器在欧洲，用户在中国，用户打开网页的时候，请求需要跨越千山万水才能达到服务器），服务器接收到用户请求的时间过长，也是导致 TTFB 时间过长的原因。浏览器中保存了过多的 Cookie，每次请求，这些 Cookie 都要发送到服务器，服务器都要处理这些 Cookie，这也是导致 TTFB 时间过长的原因之一。Waiting (TTFB) 时间过长的解决办法知道了原因，解决办法就显而易见了，那就是缩短服务器响应时间，最简单直接并且有效的办法就是使用缓存，把 PHP 和 MySQL 的执行时间最小化，一些缓存插件可以把 SQL 查询结果缓存起来，把几十次查询结果转换为几次；一些缓存插件可以直接把用户所请求的页面静态化，用户打开网页时，相当于直接从服务器上下载了静态页面。如果是网络原因，换一个服务器是比较直接的解决办法。如果因为一些原因不能换服务器，可以使用一个 CDN，把页面同步到离用户比较近的 CDN 节点上，也是一个不错的解决办法。如果是 Cookie 的原因，可以通过修改应用程序，删除一些不必要的 Cookie，或者精简 Cookie 内容，缩短 Cookie 的有效期等，都是解决办法。参考谷歌开发者文档: 了解 Resource Timing"},{"title":"解构赋值","date":"2019-02-14T02:38:12.000Z","url":"/2019/02/14/结构赋值/","tags":["javascript"],"categories":["javascript"],"content":"解构赋值稍微复杂一点的解构赋值上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。undefined就会触发函数参数的默认值。用途交换变量的值从函数返回多个值函数参数的定义提取JSON数据函数参数的默认值遍历Map结构输入模块的指定方法"},{"title":"javascript回流和重绘","date":"2018-12-17T02:31:12.000Z","url":"/2018/12/17/javascript回流和重绘/","tags":["javascript"],"categories":["javascript"],"content":"一. 什么是DOMDOM: Document Object Model 文档对象模型只有JavaScript才能调用DOM这个API吗?答案是否Python也可以访问DOMPS: 实质上还存在CSSOM: CSS Object Model, 浏览器将CSS代码解析成树形的数据结构，与DOM是两个独立的数据结构浏览器渲染过程讨论DOM操作成本，肯定要先了解该成本的来源，那么就离不开浏览器渲染解析HTML，构建DOM树（这里遇到外链，此时会发起请求）解析CSS，生成CSS规则树合并DOM树和CSS规则，生成render树布局render树（Layout/reflow），负责各元素尺寸、位置的计算绘制render树（paint），绘制页面像素信息浏览器会将各层的信息发送给GPU，GPU将各层合成（composite），显示在屏幕上1. 构建DOM树无论是DOM还是CSSOM, 都要经过 Bytes -&gt; characters -&gt; tokens -&gt; nodes -&gt; objectmodelDOM树构建过程: 当前节点的所有子节点都构建好后才会去构建当前节点的下一个 兄弟节点。2. 构建CSSOM树上述也提到了CSSOM的构建过程，也是树的结构，在最终计算各个节点的样式时，浏览器都会先从该节点的普遍属性（比如body里设置的全局样式）开始，再去应用该节点的具体属性。还有要注意的是，每个浏览器都有自己默认的样式表，因此很多时候这棵CSSOM树只是对这张默认样式表的部分替换。3. 生成render树DOM树和CSSOM树合并生成render树简单描述这个过程：DOM树从根节点开始遍历可见节点，这里之所以强调了“可见”，是因为如果遇到设置了类似 display:none;的不可见节点，在render过程中是会被跳过的（但 visibility:hidden;opacity:0这种仍旧占据空间的节点不会被跳过render），保存各个节点的样式信息及其余节点的从属关系。4. Layout 布局有了各个节点的样式信息和属性，但不知道各个节点的确切位置和大小，所以要通过布局将样式信息和属性转换为实际可视窗口的相对大小和位置。5. Paint 绘制万事俱备，最后只要将确定好位置大小的各节点，通过GPU渲染到屏幕的实际像素。Tips在上述渲染过程中，前3点可能要多次执行，比如js脚本去操作dom、更改css样式时，浏览器又要重新构建DOM、CSSOM树，重新render，重新layout、paint；Layout在Paint之前，因此每次Layout重新布局（reflow 回流）后都要重新出发Paint渲染，这时又要去消耗GPU；Paint不一定会触发Layout，比如改个颜色改个背景；（repaint 重绘）图片下载完也会重新出发Layout和Paint；二. 回流和重绘何时触发reflow(回流): 根据Render Tree布局(几何属性)，意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树；repaint(重绘): 意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了；所以reflow回流的成本开销要高于repaint重绘，一个节点的回流往往回导致子节点以及同级节点的回流GoogleChromeLabs 里面有一个csstriggers，列出了各个CSS属性对浏览器执行Layout、Paint、Composite的影响。引起reflow回流现代浏览器会对回流做优化，它会等到足够数量的变化发生，再做一次批处理回流。页面第一次渲染（初始化）DOM树变化（如：增删节点）Render树变化（如：padding改变）浏览器窗口resize获取元素的某些属性：浏览器为了获得正确的值也会提前触发回流，这样就使得浏览器的优化失效了，这些属性包括offsetLeft、offsetTop、offsetWidth、offsetHeight、 scrollTop/Left/Width/Height、clientTop/Left/Width/Height、调用了getComputedStyle()或者IE的currentStyle引起repaint重绘reflow回流必定引起repaint重绘，重绘可以单独触发背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）优化reflow、repaint触发次数避免逐个修改节点样式，尽量一次性修改使用DocumentFragment将需要多次修改的DOM元素缓存，最后一次性append到真实DOM中渲染可以将需要多次修改的DOM元素设置 display:none，操作完再显示。（因为隐藏元素不在render树内因此 修改隐藏元素不会触发回流重绘）避免多次读取某些属性（见上）将复杂的节点元素脱离文档流，降低回流成本DOMContentLoaded 和 loadDOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片…load 事件触发时，页面上所有的DOM，样式表，脚本，图片都已加载完成CSS 资源阻塞渲染构建Render树需要DOM和CSSOM，所以HTML和CSS都会阻塞渲染。所以需要让CSS尽早加载（如：放在头部），以缩短首次渲染的时间。JS 资源阻塞浏览器的解析，也就是说发现一个外链脚本时，需等待脚本下载完成并执行后才会继续解析HTML。这和之前文章提到的浏览器线程有关，浏览器中js引擎线程和渲染线程是互斥的，详见《从setTimeout-setInterval看JS线程》普通的脚本会阻塞浏览器解析，加上defer或async属性，脚本就变成异步，可等到解析完毕再执行。async异步执行，异步下载完毕后就会执行，不确保执行顺序，一定在onload前，但不确定在DOMContentLoaded事件的前后defer延迟执行，相对于放在body最后（理论上在DOMContentLoaded事件前）浏览器拿到HTML后，从上到下顺序解析文档此时遇到css、js外链，则同时发起请求开始构建DOM树这里要特别注意，由于有CSS资源，CSSOM还未构建前，会阻塞js（如果有的话）无论JavaScript是内联还是外链，只要浏览器遇到 script 标记，唤醒 JavaScript解析器，就会进行暂- 停 blocked 浏览器解析HTML，并等到 CSSOM 构建完毕，才执行js脚本渲染首屏（DOMContentLoaded 触发，其实不一定是首屏，可能在js脚本执行前DOM树和CSSOM已经构建完- render树，已经paint）首屏优化Tips说了这么多，其实可以总结几点浏览器首屏渲染优化的方向：减少资源请求数量（内联亦或是延迟动态加载）使CSS样式表尽早加载，减少@import的使用，因为需要解析完样式表中所有import的资源才会算CSS资源下载完异步js：阻塞解析器的 JavaScript 会强制浏览器等待 CSSOM 并暂停 DOM 的构建，导致首次渲染的时间延迟"},{"title":"nodejs一些学习","date":"2018-12-16T02:19:12.000Z","url":"/2018/12/16/nodejs一些学习/","tags":["nodejs"],"categories":["nodejs"],"content":"process: 进程path: 路径"},{"title":"this","date":"2018-11-28T02:19:12.000Z","url":"/2018/11/28/this/","tags":["javascript"],"categories":["javascript"],"content":"一. 全局执行二. 函数中执行非严格模式中严格模式三. 作为对象的方法调用当一个函数被当作一个对象的方法调用的时候，this 指向当前的对象 obj如果把对象的方法赋值给一个变量，调用该方法时，this 指向 Window：四. 作为构造函数使用在 JS 中，为了实现类，我们需要定义一些构造函数，在调用一个构造函数的时候加上 new 这个关键字：如果构造函数当做普通函数来调用,  this则指向Window五. 在定时器中使用如果没有特殊指向，setInterval 和setTimeout 的回调函数中 this 的指向都是 Window 。这是因为 JS 的定时器方法是定义在 Window 下的。六. 箭头函数全局环境下调用作为对象的一个函数调用特殊情况：结合定时器调用若在对象的函数中，普通函数作为定时器延时执行的函数调用，this 指向 Window；箭头函数作为定时器延时执行的函数调用， this 指向定义时所在的对象，也就是 func 中的 this，即 obj。箭头函数中 this 的值取决于该函数外部非箭头函数的 this 的值，且不能通过 call() 、 apply() 和 bind() 方法来改变 this 的值。七. call, apply, bindcall它会立即执行函数, 第一个函数是指执行函数中的上下文, 后面的参数是执行函数需要传入的参数apply它也会立即执行函数，第一个参数是指定执行函数中 this 的上下文，第二个参数是一个数组，是传给执行函数的参数（与 call 的区别）bind它不会执行函数，而是返回一个新的函数，这个新的函数被指定了 this 的上下文，后面的参数是执行函数需要传入的参数例子:示例中，call、apply 和 bind 的 this 都指向了 obj，都能正常运行；call、apply 会立即执行函数，call 和 apply 的区别就在于传递的参数，call 接收多个参数列表，apply 接收一个包含多个参数的数组；bind 不是立即执行函数，它返回一个函数，需要执行 p2 才能返回结果，bind 接收多个参数列表。应用: 改变this的指向使用es6的箭头函数在函数内部使用_this = this略使用call/apply/bindnew 实例化一个对象"},{"title":"vue-router","date":"2018-11-11T12:40:12.000Z","url":"/2018/11/11/vue-router/","tags":["vue"],"categories":["vue"],"content":"一. 单页应用以前我们的网页应用都是输入一个url, 前端会请求后台, 后台返回一个新的html文件, 让前端进行渲染, 现在很多单页应用在浏览器地址栏输入url后, 都是不经过后台的, 仅仅是前端的javascript去处理路由的跳转, 那么我们就需要一个称职合理的路由工具来帮我们完成前端路由跳转的一些相关的工作, 那么现在前端框架都会配备自己的路由处理工具, 像vue 使用的是vue-router, react 使用的是react-router, angularjs 使用的是ng-router和ui-router, 还有不跟框架耦合的工具有 history 等等二. 安装三. 创建路由相关文件routes.jsrouter.js对应的main.jsapp.vue四. 路由的一些参数配置mode(路由的模式):hash(默认)history其中history路由默认不会在路由后面加#, 一般用于服务端渲染的情况, 对SEO比较友好注意: 使用history模式的时候还要在 webpack的配置文件中的 devServer 配置中加一行配置 historyApiFallback: {index: ‘/index.html’} , 否则会显示Cannot get /… (原因为 当用户再前端页面进行手动刷新页面时, 如果没有处理, 输入url后会请求到后台对应的地址, 后台没有对此url进行配置的话就会返回404 cannot get… , 在webpack中配置了historyApiFallback属性的话webpack就会帮我们处理 history路由模式的请求, 拦截到并对应到我们的路由的组件 )base:默认会在我们写的路有前面加上这个配置的名称例: base: ‘/home/‘,在浏览器地址栏输入对应的地址的时候, localhost:3000 会跳转到 localhost:3000/home/app(在路由配置文件里配置了 redirect 属性为 ‘/app’ 时)注意: 在使用vue-router提供的一些api进行路由跳转的时候会加上base配置的内容, 但是手动在地址栏输入不带base配置的路由的时候还是能显示出来的,  所以这个不是强制的, (此属性不是很常用)linkActiveClass:router-link 标签在激活时的 class , (路由模糊匹配)linkExactActiveClass:router-link 标签在激活时的 class , (完全匹配)scrollBehavior:parseQuery:自定义将路由上的参数 从字符串转成对象的方法(不常用)stringifyQuery:自定义将的参数 从对象转成路由上的字符串的方法(不常用)fallback:true 或者 false设置为true时, 如果浏览器不支持history模式, 会自动帮我们跳回hash模式五. 路由命名在 routes.js 文件里, 配置name属性,  配置了路由的name后, 可以在标签中的 :to属性设置 “{name: ‘app’}” 这种写法六. 路由参数meta: objectchildren: array七. 路由动画要想让路由标签的内容有动画显示, 就可以直接在外层包裹一个 &lt;transition name=&quot;fade&quot;&gt; 标签(其中标签的name属性可以自定义), 然后在样式文件中定义几个类:props 还可以传一个方法, 可以自定义要传入的参数, 方法接收一个参数, 该参数为完整的route对象, 例:推荐使用此种路由传参的处理方法,尽量不要在组件中使用this.$route 的这种写法, 可以让组件跟路由解耦, 这样组件的复用性会变得更高九. 命名视图一个页面有两个部分, 在不同的路由下, 显示不同的东西, 要怎么办呢, 就要在标签上给他命名 例如:  和  在routes.js中 的 component 属性要变成一个对象  components: { a: App, b: Login }十. 导航守卫在main.js中,  全局导航守卫的钩子函数:"},{"title":"eslint","date":"2018-10-28T08:21:12.000Z","url":"/2018/10/28/eslint/","tags":["eslint"],"categories":["eslint"],"content":"eslint在项目中使用eslint 可以给我们的代码定义一些语法规范, 防止我们在语法上犯一些低级的错误, 格式上的问题, 团队协作时大家都使用统一的代码风格去书写, 让我们在看别人的代码时更方便.在项目中安装依赖再添加一个.eslintrc 文件:再在package.json文件中添加 eslint 校验命令修复命令校验时报错在运行 lint 命令时 jsx 文件报错: Parsing error: Unexpected token =经过网上查找资料, 再安装一个 babel-eslint 依赖,安装后再在 .eslintrc 文件添加一行一般我们使用webpack 和 babel 进行开发的时候我们都会指定他的 parse 为 babel-eslint,因为 eslint 对有一些 es6 的语法不是很支持我们还需要在 webpack 的 module 配置中最开始加上:此时只是用命令对我们的代码进行检查, 下面是配置编辑器直接在写代码的时候立即提示出有语法问题的代码git commit 钩子插件: husky在正式的项目中, 我们会有团队协作, 我们可以在git commit 的对应 hook 进行 eslint 的检查,首先要安装 husky:注意: 在安装一些git hook 工具的时候, npm install 之前, 项目跟目录一定要是一个git 仓库, 这样对应的工具才能初始化成功, 不然会有问题,然后配置 husky:在package.json文件中添加:配置好后每次 commit 的时候 eslint 都会去检测代码中的语法规范git commit message插件: commitline安装:默认使用angularjs 的规范"},{"title":"vue入门","date":"2018-10-06T12:18:13.000Z","url":"/2018/10/06/vue入门/","tags":["vue"],"categories":["vue"],"content":"一、vue实例1.1 vue实例的创建和作用1.2 vue实例的属性1.3 vue实例的方法二、vue的生命周期beforeCreatecreatedbeforeMountmountedbeforeUpdateupdatedbeforeDestroydestroyed三、vue的属性watch: 一般情况下, watch在初始化的时候是不会执行一次的, 如果想要在组件初始化的时候就执行, 需要在computed属性对应的监听对象下面写immediate: true, 深度监听要用deep: true,   watch监听的对象还可以用对象的点语法来写注意一般情况下不要在computed和watch里面去修改原来的值, 有可能造成无限循环 四、vue指令1、 原生指令:五、vue 插槽1、 普通插槽作用: vue组件不用于一般的html标签, 在组件内部再写html标签不会渲染, 但是一些组件的功能仅仅是给另一些组件包一层样式, 在里面还需要另外的组件定义:使用: 直接在组件里面包着要放入的内容, 此处带有插槽的组件为Feature2、 具名插槽作用: 组件内部需要多处不同的放置东西的情况定义:使用:3、 作用域插槽作用: 调用插槽的组件处可以使用定义插槽组件内部的一些变量定义:使用:修饰符在上例使用的 event.pr巳ventDefault()也可以用 Vue 事件的修饰符来实现，在@绑定的事件后加小圆点“.”，再跟一个后缀来使用修饰符。 Vue支持以下修饰符:.stop.prevent.capture.self.once.lazy.trim.number具体用法如下:在表单元素上监昕键盘事件时，还可以使用按键修饰符，比如按下具体某个键时才调用方法:只有在 keyCode 是 13 时调用 vm.submit()也可以自己配置具体按键:Vue.config.keyCodes.f1 = 112; //全局定义后，就可以使用自 keyup.f1例如:除了具体的某个 keyCode 外， Vue 还提供了 一些快捷名称，以下是全部的别名:.enter.tab.delete (捕获“删除”和“退格”键).esc.space.up.down.left.right这些按键修饰符也可以组合使用，或和鼠标一起配合使用:.ctrl.alt.shift.meta (Mac 下是 Command 键，Windows 下是窗口键)自定义组件的v-model实现一个具有双向绑定的v-model组件要满足下面两个需求接收一个 value 属性在有新的 value 时触发 input 事件注意需要注意 的是，以下变动的数组中， Vue 是不能检测到的，也不会触发视图更新:"},{"title":"无状态组件的最佳写法","date":"2018-09-27T01:34:11.000Z","url":"/2018/09/27/无状态组件的最佳写法/","tags":["react"],"categories":["react"],"content":"默认渲染行为的问题在React Component的生命周期中，有一个shouldComponentUpdate方法。这个方法默认返回值是true。这意味着就算没有改变组件的props或者state，也会导致组件的重绘。这就经常导致组件因为不相关数据的改变导致重绘，这极大的降低了React的渲染效率调用了setState方法后, 会触发组件的render方法, 并且state如果有传给子组件的话也会导致子组件的更新, 但是如果 setState前后组件的state并没有改变的话, 还是会触发组件极其子组件的更新, 这样就造成了性能的浪费, 所以可以使用react提供的 PureComponent组件.如果Temp组件不使用PureComponent组件, 而是使用普通的无状态组件的话, 当父组件的定时器在跑的时候, Temp组件也会不断的render, 造成了性能的浪费.使用PureComponent后可以看到, Temp组件不会render了好处: 提升性能, 可以少写shouldComponentUpdate原理当组件更新时，如果组件的 props 和 state 都没发生改变， render 方法就不会触发，省去 Virtual DOM 的生成和比对过程，达到提升性能的目的。具体就是 React 自动帮我们做了一层浅比较：而 shallowEqual 又做了什么呢？会比较 Object.keys(state | props) 的长度是否一致，每一个 key 是否两者都有，并且是否是一个引用，也就是只比较了第一层的值，确实很浅，所以深层的嵌套数据是对比不出来的。易变数据不能使用一个引用会发现，无论怎么点 delete 按钮， li 都不会变少，因为 items 用的是一个引用， shallowEqual 的结果为 true 。改正这样每次改变都会产生一个新的数组，也就可以 render 了。结束语PureComponent 真正起作用的，只是在一些纯展示组件上，复杂组件用了也没关系，反正 shallowEqual 那一关就过不了，不过记得 props 和 state 不能使用同一个引用哦。"},{"title":"dva","date":"2018-09-25T07:40:15.000Z","url":"/2018/09/25/dva/","tags":["react"],"categories":["react"],"content":"笔记只有在 router.js 定义使用的 component 对应的 component 才能从组件的 props 中提取到 history 属性的要解决这个问题的话, 对应的组件要使用react-router-dom 的高阶组件 withRouter, 导出时用 withRouter(ComponentName) 包裹, 注意点: dva中使用 withRouter 要从dva的router库导入, 路径为 ‘dva/router’"},{"title":"git hook","date":"2018-09-25T07:40:15.000Z","url":"/2018/09/25/git hook/","tags":["git"],"categories":["git"],"content":"git hook有时候, 在使用git提交代码的时候, 需要先用语法检查工具来检查项目中是否有不符合规范的语法, 如果有, 就不能提交代码所以就要 git hook比如commit 前执行 eslint的检测操作,  如果eslint的语法检查没有校验通过则不能进行提交要安装 husky 依赖,  注意安装依赖的时候  目录一定是要初始化好的 git 仓库,  不然此依赖找不到对应的git 进行hook"},{"title":"封装","date":"2018-09-17T08:33:11.000Z","url":"/2018/09/17/面向对象-封装/","tags":["教程"],"categories":["教程"],"content":"创建一个类平常我们说的一些对象的公有属性,私有属性,公有方法,私有方法,特权方法,静态属性,静态方法这么多的名词到底是什么这样一个Book 的类就创建好了, 但是从开始定义Book = function…开始到最后感觉整个类的相关的定义是分开的, 不是一个整体, 所以一般就用闭包来将代码封装到一块:"},{"title":"redux-saga","date":"2018-09-11T07:01:15.000Z","url":"/2018/09/11/redux-saga/","tags":["react"],"categories":["react"],"content":"概述redux-saga是一个用于管理redux应用异步操作的中间件，redux-saga通过创建sagas将所有异步操作逻辑收集在一个地方集中处理，可以用来代替redux-thunk中间件这意味着应用的逻辑会存在两个地方(1) reducer负责处理action的stage更新(2) sagas负责协调那些复杂或者异步的操作sagas是通过generator函数来创建的sagas可以被看作是在后台运行的进程。sagas监听发起的action，然后决定基于这个action来做什么 (比如：是发起一个异步请求，还是发起其他的action到store，还是调用其他的sagas 等 )在redux-saga的世界里，所有的任务都通过用 yield Effects 来完成 ( effect可以看作是redux-saga的任务单元 )Effects 都是简单的 javascript对象，包含了要被 saga middleware 执行的信息redux-saga 为各项任务提供了各种 （ Effects创建器 )因为使用了generator函数，redux-saga让你可以用 同步的方式来写异步代码redux-saga启动的任务可以在任何时候通过手动来取消，也可以把任务和其他的Effects放到 race 方法里以自动取消produce: 生产flow: 流动，排出整个流程：ui组件触发action创建函数 —&gt; action创建函数返回一个action ——&gt; action被传入redux中间件(被 saga等中间件处理) ，产生新的action，传入reducer——-&gt; reducer把数据传给ui组件显示 —–&gt; mapStateToProps ——&gt; ui组件显示名词解释Effect一个effect就是一个纯文本javascript对象，包含一些将被saga middleware执行的指令。如何创建 effect ?使用redux-saga提供的 工厂函数 来创建effect比如：你可以使用  call(myfunc,  ‘arg1’, ‘arg2’)  指示middleware调用  myfunc(‘arg1’, ‘arg2’)并将结果返回给 yield 了 effect  的那个  generatorTask一个 task 就像是一个在后台运行的进程，在基于redux-saga的应用程序中，可以同时运行多个task通过 fork 函数来创建 task阻塞调用 和 非阻塞调用阻塞调用阻塞调用的意思是： saga 会在 yield 了 effect 后会等待其执行结果返回，结果返回后才恢复执行 generator 中的下一个指令非阻塞调用非阻塞调用的意思是： saga 会在 yield effect 之后立即恢复执行watcher 和 worker指的是一种使用两个单独的saga来组织控制流的方式watcher：监听发起的action 并在每次接收到action时 fork 一个 workworker： 处理action，并结束它apicreateSagaMiddleware(…sagas)createSagaMiddleware的作用是创建一个redux中间件，并将sagas与Redux store建立链接参数是一个数组，里面是generator函数列表sagas: Array —- ( generator函数列表 )middleware.run(saga, …args)动态执行 saga。用于 applyMiddleware 阶段之后执行 Sagas。这个方法返回一个Task 描述对象。saga: Function: 一个 Generator 函数args: Array: 提供给 saga 的参数 (除了 Store 的 getState 方法)take(pattern)—– 暂停Generator，匹配的action被发起时，恢复执行创建一条 Effect 描述信息，指示 middleware 等待 Store 上指定的 action。 Generator 会暂停，直到一个与 pattern 匹配的 action 被发起。pattern的规则(1) pattern为空 或者 * ，将会匹配所有发起的action(2) pattern是一个函数，action 会在 pattern(action) 返回为 true 时被匹配（例如，take(action =&gt; action.entities) 会匹配那些 entities 字段为真的 action）。(3) pattern是一个字符串，action 会在 action.type === pattern 时被匹配(4) pattern是一个数组，会针对数组所有项，匹配与 action.type 相等的 action（例如，take([INCREMENT, DECREMENT]) 会匹配 INCREMENT 或 DECREMENT 类型的 action）fork(fn, …args)—– 无阻塞的执行fn，执行fn时，不会暂停Generator—– yield fork(fn …args)的结果是一个 Task 对象task对象 ———- 一个具备某些有用的方法和属性的对象创建一条 Effect 描述信息，指示 middleware 以 无阻塞调用 方式执行 fn。fn: Function - 一个 Generator 函数, 或者返回 Promise 的普通函数args: Array - 一个数组，作为 fn 的参数fork 类似于 call，可以用来调用普通函数和 Generator 函数。但 fork 的调用是无阻塞的，在等待 fn 返回结果时，middleware 不会暂停 Generator。 相反，一旦 fn 被调用，Generator 立即恢复执行。fork 与 race 类似，是一个中心化的 Effect，管理 Sagas 间的并发。 yield fork(fn …args) 的结果是一个 Task 对象 —— 一个具备某些有用的方法和属性的对象。fork: 是分叉，岔路的意思 ( 并发 )join(task)—– 等待fork任务返回结果(task对象)创建一条 Effect 描述信息，指示 middleware 等待之前的 fork 任务返回结果。task: Task - 之前的 fork 指令返回的 Task 对象yield fork(fn, …args) 返回的是一个 task 对象cancel(task)创建一条 Effect 描述信息，指示 middleware 取消之前的 fork 任务。task: Task - 之前的 fork 指令返回的 Task 对象cancel 是一个无阻塞 Effect。也就是说，Generator 将在取消异常被抛出后立即恢复。select(selector, …args)—– 得到 Store 中的 state 中的数据创建一条 Effect 描述信息，指示 middleware 调用提供的选择器获取 Store state 上的数据（例如，返回 selector(getState(), …args) 的结果）。selector: Function - 一个 (state, …args) =&gt; args 函数. 通过当前 state 和一些可选参数，返回当前 Store state 上的部分数据。args: Array - 可选参数，传递给选择器（附加在 getState 后）如果 select 调用时参数为空( — 即 yield select() — )，那 effect 会取得整个的 state （和调用 getState() 的结果一样）重要提醒：在发起 action 到 store 时，middleware 首先会转发 action 到 reducers 然后通知 Sagas。这意味着，当你查询 Store 的 state， 你获取的是 action 被处理之后的 state。put(action)—– 发起一个 action 到 store创建一条 Effect 描述信息，指示 middleware 发起一个 action 到 Store。action: Object - 完整信息可查看 Redux 的 dispatch 文档put 是异步的，不会立即发生call(fn, …args) 阻塞执行，call()执行完，才会往下执行—– 执行 fn(…args)—– 对比 fork(fn, …args) 无阻塞执行创建一条 Effect 描述信息，指示 middleware 调用 fn 函数并以 args 为参数。fn: Function - 一个 Generator 函数, 或者返回 Promise 的普通函数args: Array - 一个数组，作为 fn 的参数fn 既可以是一个普通函数，也可以是一个 Generator 函数race(effects)effects: Object : 一个{label: effect, …}形式的字典对象同时执行多个任务当我们需要 yield 一个包含 effects 的数组， generator 会被阻塞直到所有的 effects 都执行完毕，或者当一个 effect 被拒绝 （就像 Promise.all 的行为）时，才会恢复执行Generator函数 ( yield后面的语句 )。"},{"title":"webpack自定义配置","date":"2018-08-25T14:17:09.000Z","url":"/2018/08/25/webpack自定义配置/","tags":["webpack"],"categories":["webpack"],"content":"webpack配置文件 webpack.config.js四个核心概念:入口（entry），告诉 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。 可以传入字符串, 数组, 对象, 详见官方文档entry配置出口（output），告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。 详见官方文档output配置path - 表示输出文件的路径filename - 表示输出文件的文件名加载器（loader），告诉 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。详见官方文档loader配置插件（plugin），给 webpack 添加更多的功能，使 webpack 更加的灵活和强大，webpack 有两种类型的插件: ①内置插件  ②外置插件。 详见官方文档plugin配置项目依赖文件 package.jsonvuevue-loader 作用: 解析和转换 .vue 文件，提取出其中的逻辑代码 script、样式代码 style、以及 html 模版 template，再分别把它们交给对应的 Loader 去处理。依赖: vue-loader 需要 css-loader 和 vue-template-loader 作为依赖css-loader作用: 加载由 vue-loader 提取出的 CSS 代码vue-template-loader作用: 把 vue-loader 提取出的 HTML 模版编译成对应的可执行的 JavaScript 代码，这和 React 中的 JSX 语法被编译成 JavaScript 代码类似。预先编译好 HTML 模版相对于在浏览器中再去编译 HTML 模版的好处在于性能更好。style-loaderurl-loaderurl-loader 需要 file-loader 作为依赖webpackwebpack-dev-servercross-env项目搭建时遇到的一些坑1.其中一个是在安装了webpack-dev-server后, 使用npm run dev 的时候报错,看报错信息以为要安装 webpack-cli, 但是安装后又报另一个错误, 遂去网上查询, 最后 webpack-dev-server的版本从 3.1.5 降到 2.9.7 解决2.在安装了 webpack-dev-server 后, 将 devServer 配置的 hot 属性设置为true 后并没有生效, 后台查询知道在plugin里面要加入 new webpack.HotModuleReplacementPlugin()3.vue-loader在较高的版本不仅要在module中使用vue-loader解析.vue文件, 还要导入 VueLoaderPlugin, 并且在plugins中调用 且引入的方法为 const { VueLoaderPlugin } = require(‘vue-loader’); (不要漏了大括号)4.注意配置 webpack-dev-server 的时候, port 不要设置已经被占用的端口,  否者npm run dev会报错5.要启用webpack的热更新功能不仅要把 devServer 对象的hot 设置为 true还要在plugins中增加 一个插件:  HotModuleReplacementPlugin"},{"title":"vue-computed","date":"2018-08-24T13:33:09.000Z","url":"/2018/08/24/vue-computed/","tags":["vue"],"categories":["vue"],"content":"什么是computed 计算属性所有的计算属性都以函数的形式写在 Vue 实例内的 computed选项内，最终返回计算后的结果, 用于减少模板中的代码臃肿用法还有一种写法(包含getter和setter)当执行 this.price = xxx 的时候setter就会被调用绝大多数情况下，我们只会用默认的 getter方法来读取一个计算属性，在业务中很少用到setter计算属性还有两个很实用的小技巧容易被忽略:一. 计算属性可以依赖其他计算属性二. 计算属性不仅可以依赖当前 Vue 实例的数据，还可以依赖其他实例的数据，对比methods计算属性能做到的事情, methods上同样能做到, 那么vue为什么还要定义一个属性来专门用作计算属性用呢?原因就是: 计算属性是基于它的依赖缓存的。 一个计算属性所依赖的数据发生变化时，它才会重新取值，所以只要计算属性依赖的值不改变，计算属性也就不更新使用计算属性还是 methods 取决于你是否需要缓存，当遍历大数组和做大量计算时，应当使用计算属性，除非你不希望得到缓存注意类的动态绑定也可以使用计算属性"},{"title":"vue-directive","date":"2018-08-24T12:05:42.000Z","url":"/2018/08/24/vue-directive/","tags":["vue"],"categories":["vue"],"content":"简介在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。全局自定义指令注册局部指令，组件中也接受一个 directives 的选项然后你可以在模板中任何元素上使用新的 v-focus 属性，如下钩子函数一个指令定义对象可以提供如下几个钩子函数 (均为可选)：bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新 (详细的钩子函数参数见下)。componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。unbind：只调用一次，指令与元素解绑时调用。钩子函数参数指令钩子函数会被传入以下参数：el：指令所绑定的元素，可以用来直接操作 DOM 。binding：一个对象，包含以下属性：name：指令名，不包括 v- 前缀。value：指令的绑定值，例如：v-my-directive=”1 + 1” 中，绑定值为 2。oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子中可用。无论值是否改变都可用。expression：字符串形式的指令表达式。例如 v-my-directive=”1 + 1” 中，表达式为 “1 + 1”。arg：传给指令的参数，可选。例如 v-my-directive:foo 中，参数为 “foo”。modifiers：一个包含修饰符的对象。例如：v-my-directive.foo.bar 中，修饰符对象为 { foo: true, bar: true }。vnode：Vue 编译生成的虚拟节点。移步 VNode API 来了解更多详情。oldVnode：上一个虚拟节点，仅在 update 和 componentUpdated 钩子中可用。"},{"title":"vue-mixin","date":"2018-08-24T11:55:09.000Z","url":"/2018/08/24/vue-mixin/","tags":["vue"],"categories":["vue"],"content":"选项合并当组件和混入对象含有同名选项时，这些选项将以恰当的方式混合。数据对象在内部会进行浅合并 (一层属性深度)，在和组件的数据发生冲突时以组件数据优先。同名钩子函数将混合为一个数组，因此都将被调用。另外，混入对象的钩子将在组件自身钩子之前调用。值为对象的选项，例如 methods, components 和 directives，将被混合为同一个对象。两个对象键名冲突时，取组件对象的键值对。全局混入也可以全局注册混入对象。注意使用！ 一旦使用全局混入对象，将会影响到 所有 之后创建的 Vue 实例。使用恰当时，可以为自定义对象注入处理逻辑。注意: 谨慎使用全局混入对象，因为会影响到每个单独创建的 Vue 实例 (包括第三方模板)。大多数情况下，只应当应用于自定义选项，就像上面示例一样。也可以将其用作 Plugins 以避免产生重复应用"},{"title":"JavaScript module简史","date":"2018-08-22T01:30:42.000Z","url":"/2018/08/22/JS模块简史/","tags":["教程"],"categories":["教程"],"content":"JavaScript模块化最开始,JavaScript 往往作为嵌入到 HTML 页面中的用于控制动画与简单的用户交互的脚本语言，我们习惯于将其直接嵌入到 script 标签中：不过随着单页应用与富客户端的流行，不断增长的代码库也急需合理的代码分割与依赖管理的解决方案，命名空间模式所有数据对象与函数都归属于全局对象 app，不过显而易见这种方式对于大型多人协同项目的可维护性还是较差，并且没有解决模块间依赖管理的问题。依赖注入Martin Fowler 于 2004 年提出了依赖注入（Dependency Injection）的概念，其主要用于 Java 中的组件内通信；以 Spring 为代表的一系列支持依赖注入与控制反转的框架将这种设计模式发扬光大，并且成为了 Java 服务端开发的标准模式之一。依赖注入的核心思想在于某个模块不需要手动地初始化某个依赖对象，而只需要声明该依赖并由外部框架自动实例化该对象实现并且传递到模块内。而五年之后的 2009 年 Misko Hevery 开始设计新的 JavaScript 框架，并且使用了依赖注入作为其组件间通信的核心机制。这个框架就是引领一时风骚，甚至于说是现代 Web 开发先驱之一的 Angular。Angular 允许我们定义模块，并且在显式地声明其依赖模块而由框架完成自动注入。其核心思想如下所示：CommonJS在 Node.js 横空出世之前，就已经有很多将运行于客户端浏览器中的 JavaScript 迁移运行到服务端的框架；不过由于缺乏合适的规范，也没有提供统一的与操作系统及运行环境交互的接口，这些框架并未流行开来。2009 年时 Mozilla 的雇员 Kevin Dangoor 发表了博客讨论服务端 JavaScript 代码面临的困境，号召所有有志于规范服务端 JavaScript 接口的志同道合的开发者协同讨论，群策群力，最终形成了 ServerJS 规范；一年之后 ServerJS 重命名为 CommonJS。后来 CommonJS 内的模块规范成为了 Node.js 的标准实现规范其基本语法为 var commonjs = require(“./commonjs”);，核心设计模式如下所示：该模块实现方案主要包含 require 与 module 这两个关键字，其允许某个模块对外暴露部分接口并且由其他模块导入使用。AMD就在 CommonJS 规范火热讨论的同时，很多开发者也关注于如何实现模块的异步加载。Web 应用的性能优化一直是前端工程实践中不可避免的问题，而模块的异步加载以及预加载等机制能有效地优化 Web 应用的加载速度。hello.js 作为整个应用的入口模块，我们使用 define 关键字声明了该模块以及外部依赖；当我们执行该模块代码时，也就是执行 define 函数的第二个参数中定义的函数功能，其会在框架将所有的其他依赖模块加载完毕后被执行。这种延迟代码执行的技术也就保证了依赖的并发加载。从我个人而言，AMD 及其相关技术对于前端开发的工程化进步有着非常积极的意义，不过随着以 npm 为主导的依赖管理机制的统一，越来越多的开发者放弃了使用 AMD 模式。UMDAMD 与 CommonJS 虽然师出同源，但还是分道扬镳，关注于代码异步加载与最小化入口模块的开发者将目光投注于 AMD；而随着 Node.js 以及 Browserify 的流行，越来越多的开发者也接受了 CommonJS 规范。令人扼腕叹息的是，符合 AMD 规范的模块并不能直接运行于实践了 CommonJS 模块规范的环境中，符合 CommonJS 规范的模块也不能由 AMD 进行异步加载，整个 JavaScript 生态圈貌似分崩离析。2011 年中，UMD，也就是 Universal Module Definition 规范正是为了弥合这种不一致性应运而出，其允许在环境中同时使用 AMD 与 CommonJS 规范。Q 算是 UMD 的首个规范实现，其能同时运行于浏览器环境（以脚本标签形式嵌入）与服务端的 Node.js 或者 Narwhal（CommonJS 模块）环境中；稍后，James 也为 Q 添加了对于 AMD 的支持。我们将上述例子中的 greeting.js 改写为同时支持 CommonJS 与 AMD 规范的模块：该模式的核心思想在于所谓的 IIFE（Immediately Invoked Function Expression），该函数会根据环境来判断需要的参数类别，譬如在 CommonJS 环境下上述代码会以如下方式执行：而如果是在 AMD 模块规范下，函数的参数就变成了 define。正是因为这种运行时的灵活性是我们能够将同一份代码运行于不同的环境中。ES2015 ModulesJavaScript 模块规范领域群雄逐鹿，各领风骚，作为 ECMAScript 标准的起草者 TC39 委员会自然也不能置身事外。ES2015 Modules 规范始于 2010 年，主要由 Dave Herman 主导；随后的五年中 David 还参与了 asm.js，emscription，servo，等多个重大的开源项目，也使得 ES2015 Modules 的设计能够从多方面进行考虑与权衡。而最后的模块化规范定义于 2015 年正式发布，也就是被命名为 ES2015 Modules。我们上述的例子改写为 ES2015 Modules 规范如下所示：ES2015 Modules 作为 JavaScript 官方标准，日渐成为了开发者的主流选择。虽然我们目前还不能直接保证在所有环境（特别是旧版本浏览器）中使用该规范，但是通过 Babel 等转化工具能帮我们自动处理向下兼容。此外 ES2015 Modules 还是有些许被诟病的地方，譬如导入语句只能作为模块顶层的语句出现，不能出现在 function 里面或是 if 里面，并且 import 语句会被提升到文件顶部执行，也就是说在模块初始化的时候所有的 import 都必须已经导入完成，并且 import 的模块名只能是字符串常量，导入的值也是不可变对象；比如说你不能 import { a } from ‘./a’ 然后给 a 赋值个其他什么东西。"},{"title":"Gulp的Stream","date":"2018-08-21T01:00:12.000Z","url":"/2018/08/21/Gulp的Stream/","tags":["教程"],"categories":["教程"],"content":"Stream你可能也在最初开始使用Gulp的时候就听说过：Gulp是一个有关Stream（数据流）的构建系统。这句话的意思是，Gulp本身使用了Node的Stream。Stream如其名字所示的“流”那样，就像是工厂的流水线。你要加工一个产品，不用全部在一个位置完成，而是可以拆分成多道工序。产品从第一道工序开始，第一道工序完成后，输出然后流入第二道工序，然后再第三道工序…一方面，大批量的产品需求也不用等到全部完工（这通常很久），而是可以完工一个就拿到一个。另一方面，复杂的加工过程被分割成一系列独立的工序，这些工序可以反复使用，还可以在需要的时候进行替换和重组。这就是Stream的理念。Stream在Node中的应用十分广泛，几乎所有Node程序都在某种程度上用到了Stream。管道Stream有一个很基本的操作叫做管道（pipe）。Stream是水流，而管道可以从一个流的输出口，接到另一个流的输入口，从而控制流向。如果用前面的流水线工序来说的话，就是连接工序的传输带了。Node的Stream有一个方法pipe()，也就是管道操作对应的方法。它一般这样用：其中src和dst都是stream，分别代表源和目标。也就是说，流src的输出，将作为输入转到流dst。此外，这个方法返回目标流（比如这里.pipe(dst)返回dst），因此可以链式调用：内存操作Stream的整个操作过程，都在内存中进行。因此，相比Grunt，使用Stream的Gulp进行多步操作并不需要创建中间文件，可以省去额外的src和dest。事件Node的Stream都是Node事件对象EventEmitter的实例，它们可以通过.on()添加事件侦听。类型在现在的Node里，Stream被分为4类，分别是Readable（只读）、Writable（只写）、Duplex（双向）、 Transform（转换）。其中Duplex就是指可读可写，而Transform也是Duplex，只不过输出是由输入计算得到的，因此算作Duplex的特例。Readable Stream和Writable Stream分别有不同的API及事件（例如readable.read()和writable.write()），Duplex Stream和Transform Stream因为是可读可写，因此拥有前两者的全部特性。例子虽然Node中可以通过require(&quot;stream&quot;)引用Stream，但比较少会需要这样直接使用。大部分情况下，我们用的是Stream Consumers，也就是具有Stream特性的各种子类。Node中许多核心包都用到了Stream，它们也是Stream Consumers。以下是一个使用Stream完成文件复制的例子：其中，fs.createReadStream()创建了Readable Stream的r，fs.createWriteStream()创建了Writable Stream的w，然后r.pipe(w)这个管道方法就可以完成数据从r到w的流动。如前文所说，Stream是EventEmitter的实例，因此这里的on()方法为w添加了事件侦听，事件finish是Writable Stream的一个事件，触发于写入操作完成。Vinyl文件系统虽然Gulp使用的是Stream，但却不是普通的Node Stream，实际上，Gulp（以及Gulp插件）用的应该叫做Vinyl File Object Stream。这里的Vinyl，是一种虚拟文件格式。Vinyl主要用两个属性来描述文件，它们分别是路径（path）及内容（contents）。具体来说，Vinyl并不神秘，它仍然是JavaScript Object。Vinyl官方给了这样的示例：从这段代码可以看出，Vinyl是Object，path和contents也正是这个Object的属性。Vinyl的意义Gulp为什么不使用普通的Node Stream呢？请看这段代码虽然这段代码没有用到任何Gulp插件，但包含了我们最为熟悉的gulp.src()和gulp.dest()。这段代码是有效果的，就是将一个目录下的全部.css文件，都复制到了另一个目录。这其中还有一个很重要的特性，那就是所有原目录下的文件树，包含子目录、文件名等，都原封不动地保留了下来。普通的Node Stream只传输String或Buffer类型，也就是只关注“内容”。但Gulp不只用到了文件的内容，而且还用到了这个文件的相关信息（比如路径）。因此，Gulp的Stream是Object风格的，也就是Vinyl File Object了。到这里，你也知道了为什么有contents、path这样的多个属性了。vinyl-fsGulp并没有直接使用vinyl，而是用了一个叫做vinyl-fs的模块（和vinyl一样，都是npm）。vinyl-fs相当于vinyl的文件系统适配器，它提供三个方法：.src()、.dest()和.watch()，其中.src()将生成Vinyl File Object，而.dest()将使用Vinyl File Object，进行写入操作。在Gulp源码index.js中，可以看到这样的对应关系：也就是说，gulp.src()和gulp.dest()直接来源于vinyl-fs类型Vinyl File Object的contents可以有三种类型：Stream、Buffer（二进制数据）、Null（就是JavaScript里的null）。需要注意的是，各类Gulp插件虽然操作的都是Vinyl File Object，但可能会要求不同的类型。在使用Gulp过程中，可能会碰到incompatible streams的问题这个问题的原因一般都是Stream与Buffer的类型差异。Stream如前文介绍，特性是可以把数据分成小块，一段一段地传输，而Buffer则是整个文件作为一个整体传输。可以想到，不同的Gulp插件做的事情不同，因此可能不支持某一种类型。例如，gulp-uglify这种需要对JavaScript代码做语法分析的，就必须保证代码的完整性，因此，gulp-uglify只支持Buffer类型的Vinyl File Object。gulp.src()方法默认会返回Buffer类型，如果想要Stream类型，可以这样指明:Stream转换为了让Gulp可以更多地利用当前Node生态体系的Stream，出现了许多Stream转换模块。下面介绍一些比较常用的。vinyl-source-streamvinyl-source-stream 可以把普通的Node Stream转换为Vinyl File Object Stream。这样，相当于就可以把普通Node Stream连接到Gulp体系内。具体用法是这段代码中的Stream管道，作为起始的并不是gulp.src()，而是普通的Node Stream。但经过vinyl-source-stream的转换后，就可以用gulp.dest()进行输出。其中source([filename])就是调用转换，我们知道Vinyl至少要有contents和path，而这里的原Node Stream只提供了contents，因此还要指定一个filename作为path。vinyl-source-stream中的stream，指的是生成的Vinyl File Object，其contents类型是Stream。类似的，还有vinyl-source-buffer，它的作用相同，只是生成的contents类型是Buffer。vinyl-buffervinyl-buffer接收Vinyl File Object作为输入，然后判断其contents类型，如果是Stream就转换为Buffer。很多常用的Gulp插件如gulp-sourcemaps、gulp-uglify，都只支持Buffer类型，因此vinyl-buffer可以在需要的时候派上用场。Gulp错误处理Gulp有一个比较令人头疼的问题是，如果管道中有任意一个插件运行失败，整个Gulp进程就会挂掉。尤其在使用gulp.watch()做即时更新的时候，仅仅是临时更改了代码产生了语法错误，就可能使得watch挂掉，又需要到控制台里开启一遍。对错误进行处理就可以改善这个问题。前面提到过，Stream可以通过.on()添加事件侦听。对应的，在可能产生错误的插件的位置后面，加入on(&quot;error&quot;)，就可以做错误处理：如果你不想这样自己定义错误处理函数，可以考虑gulp-util的.log()方法。另外，这种方法可能会需要在多个位置加入on(“error”)，此时推荐gulp-plumber，这个插件可以很方便地处理整个管道内的错误。据说Gulp下一版本，Gulp 4，将大幅改进Gulp的错误处理功能，敬请期待解答现在，来回答本文开头的问题吧。b.bundle()生成了什么，为什么也可以.pipe()？b.bundle()生成了Node Stream中的Readable Stream，而Readable Stream有管道方法pipe()。为什么不是从gulp.src()开始？Browserify来自Node体系而不是Gulp体系，要结合Gulp和Browserify，适当的做法是先从Browserify生成的普通Node Stream开始，然后再转换为VInyl File Object Stream连接到Gulp体系中。为什么还要vinyl-source-stream和vinyl-buffer？它们是什么？因为Gulp插件的输入必须是Buffer或Stream类型的Vinyl File Object。它们分别是具有不同功能的Stream转换模块。添加在中间的.on(&#39;error&#39;, gutil.log)有什么作用？错误处理，以便调试问题。"},{"title":"git一些命令","date":"2018-08-20T01:00:12.000Z","url":"/2018/08/20/git一些命令/","tags":["教程"],"categories":["教程"],"content":"Git diff通常情况下，我们会在自己的独立分支中完成需求开发，此时就会有需求将自己的分支和其他分支进行对比。这个功能可以通过命令来对比branch1和branch2分支的区别, 列出每一个有改动文件的具体改动.如果希望对比暂存区和当前的 HEAD，那么使用命令会非常方便。普通的 git diff 命令默认对比的是没有加到索引中的文件。恢复暂存区如果已经将一些文件添加到暂存区后又后悔了，Git 提供了多个命令来实现这个功能，具体需要根据当时情况而定。命令将文件从暂存区索引中删除，但是仍然会将文件保留在工作目录。这比直接使用命令直接完全删除文件会安全一点Git reset如果希望恢复一些已经提交的改动，我们可以使用命令。该命令有许多不同的行为，因此需要按照实际场景进行使用。如果希望的是去除所有修改，包括索引中的内容和工作目录中的修改，那么可以使用如果仅仅是希望重置索引，那么可以使用命令，这也是 git reset 命令的默认行为。混合的重置会保留当前工作目录中的改动。最后，如果仅仅希望修改分支的 HEAD，可以通过实现当运行 git reset 命令的时候，我们可以指定多个目标文件作为参数传入。当然可以通过恢复到指定的提交版本。Git stash大家应该对 git stash 命令并不陌生，它可以通过 git stash pop 命令方便的将之前的改动恢复回来。然而，如果工作目录中有未追踪的文件，默认情况下是不会将其存入临时储藏区的。为了能够临时保存未追踪的文件，可以使用命令。另外一个非常有用的命令是它能列出临时储藏区中的内容。历史记录Git 自带了非常强大的工具来查看项目以及特定文件的变更情况。我个人非常喜欢用其中的一个命令：用以展示经过修饰的提交历史。这个命令非常冗长，因此我建议可以为它创建一个别名（这可能是所有技巧中最有用的，因为许多命令都比较难记）。git log 命令可以显示 HEAD、所有提交的 ID 以及分支信息。有了这些信息之后，我们可以使用命令来显示更详细的信息。有的时候我们需要了解谁对一个文件做了哪些改动，这正是命令所提供的功能。之前提到过 git diff 命令，它也是一个查看历史的工具。例如，如果需要对比当前 HEAD 和前两个提交，可以使用为了能够展示每个提交中的更详细的更新信息，可以使用命令。如果只想要看包含关键字“apple”的提交，使用命令。需要查看历史提交记录中两个点之间的提交历史，我们可以用命令，对于分支可以使用显示 master 分支的文件的改动修复错误提交注意：以下一些命令会修改提交历史，使用前请确保了解后再执行。当提交出错时，我们可能会希望能够修改提交历史。我不建议修改已经推送到远程仓库的提交历史（即使 git 允许这样做），但是对于本地仓库的提交历史，我个人认为还是可以修改的。通过命令可以删除前一次提交，并创建一个新的提交记录以替代之前的提交。另一个我最喜欢的 git 使用技巧是交互式变基 (rebase）。它可以用来编辑提交信息，或者将多个提交压缩成一个提交，这也是我最喜欢的一个功能。为了在远程仓库 origin 的 master 分支之后的所有提交上执行交互式变基，可以使用该命令会显示提交列表和可执行操作的详细描述。例如以下操作将会把多个提交压缩成一个：最终的结果会是生成一个提交消息为“Add feature X”的提交。如果需要恢复一个有问题的提交，我们可以使用该命令会创建一个新的提交，让当前项目状态恢复到指定提交之前。如果我们在修复问题时出现了误操作，例如不小心删除了不应该删除的文件。我们还是可以从版本库中恢复回来，因为 git 保存了所有修改的版本，包括被移除的提交。git reflog 命令就是用来实现这个功能的。挑拣提交（cherry-pick）假设我们和同事在各自单独的分支上进行开发，同事有一个重要的提交我们也想应用到自己的分支上来，但是不需要对方分支的其他提交。这时我们可以使用将log 输出成工整好看的形式要看在某个时间段内的commit把当前代码提交到另一个远程git仓库假如仓库repo_a当前位于branch_a，要求将branch_a的整个数据（包括提交历史）全部提取出来，并建立一个新的仓库repo_b。这里假设仓库repo_b已经被建立。git remote add基本语法如下。name和url是必须的。以下命令用于将本地的分支推向远端的分支:写在最后以上都是我最喜欢的 git 实用技巧。希望你也能从中学到一些新知识。这些都是我在日常使用中发现非常有用的命令，它们对我的日常工作非常有用。如果你也有类似常用的 git 实用技巧或者常用命令，可以分享出来大家一起交流。"},{"title":"AngularJS复杂业务系统的代码架构探索","date":"2018-08-19T12:56:41.000Z","url":"/2018/08/19/angularjs复杂业务系统的代码架构探索/","tags":["angularjs"],"categories":["angularjs"],"content":"模型系统的前世 – “模糊系统”开发阶段: controller里面的代码初始化视图模型, 视图展示元素的文字及显示影藏等等属性(ng-show/ng-if)定义事件响应函数, 处理UI交互逻辑(ng-click/ng-change)定义scope中, 指令需要的配置参数指令和controller的作用域的数据传递作用域内部属性变动的监听作用域之间的数据通信业务逻辑维护阶段上面那样写出来的代码, 在维护的时候就是一团糟测量代码质量的标准是, 在代码reveive每分钟WTF(what the fuck)的数量带来的沉思代码级别的重构解决不了问题每个人开发的项目不同,思路不同,所有优化和重构的策略也不同,导致重构后的代码风格不同,甚至,重构优化过的代码在面临需求变更的时候出现反复不是哪个程序员的问题不是因为某个程序员或者某几个程序员故意那样写,而是因为简单项目中,使用angularjs那样写就是快,就是简单,产品经理规定的一周的工作说不定你3天就做完了是发展中的问题两个维度: (1)一个复杂的业务系统,从最初的0.0版本的需求到最终多次需求迭代变更之后,系统自然而然的会出现这样的问题,初期写的很简单的代码在后期需要加需求是带来很多困扰. (2)从项目组来说,这种问题存在于整个项目组的成长期,不是突然冒出来的,也不会突然消失,必须认真对待,合理规划产品规模化以后是最大的问题某一个项目存在这样的问题不可怕,可怕的是大部分项目都存在这样的问题,当产品规模化了以后,项目越来越多,只有最开始的开发者才能做维护,那么后期维护和需求迭代的投入只会让团队积重难返模型系统的初现 – 面向对象程序设计面向对象程序设计的手段(方法)是什么 ?继承/组合封装多态这些都是被说烂了的概念不是因为你写了个prototype扩展一下就是面向对象了,或许真实情况是, 你仅仅是代码用了继承的写法而已而是一个设计过程, 也就是说, 在写代码之前, 你设计了一套东西, 不管是框架也好, 是一个小功能也好, 是一个组件也好, 这个东西符合面向对象的思维, 然后你为了实现这套东西, 使用了继承/组合,封装,多态等等写代码的手法面向对象程序设计的精粹(预算)是什么 ?职责单一: 一个类, 只承担它应该处理的职责, 其他相关的事物可以通过不同职责的类之间的组合或聚合来完成开放封闭: 对扩展开放, 对修改封闭, 如果你的代码在增加一个新功能的时候, 只用新增一个文件, 就能将功能加上去, 而不用去修改原有的逻辑, 就是符合开放的原则的依赖倒转: (非常关键) 依赖抽象, 而不是依赖实现, 抽象就是传说中的接口, 实现就是接口的具体逻辑, 改了具体的实现, 不会波及到其他模块的相关类, 这就是开放封闭原则成为可能里氏替换: 继承必须确保超类所拥有的性质在子类中仍然成立, 换言之, 程序中, 所有使用了超类的地方, 都可以使用子类去替代而不引发任何错误如何解决controller当前面临的问题(最大的问题, 什么都在controller里面写)职责单一controller职责梳理负责UI相关的数据初始化负责不同模块之间的数据通信负责UI交互的逻辑处理不负责业务逻辑基本行为的抽象可以利用模板方法模式将常用的controller初始化过程抽象为一系列标准的初始化方法, 子类根据实际类型去做不同方法的复写常用功能的封装在原有的基础上做功能行的封装提供全局事件注册, 销毁快速接口提供模型获取的快速接口等等提供内部的注册属性, 方法等机制不用职责和功能组件的组合业务组件UI组件Directive 等等如何解决业务逻辑膨胀式增长的问题 ?可扩展性按照业务逻辑划分模块明确模块职责对业务模块进行建模业务模块根据配置或者运行时,自助注入controller通过事件机制完成模块间的数据通信和交流业务模块之间的业务关系及监护,尽量采用事件机制和promise配合业务组件的复用同一个系统内部多次出现的跟某个业务相关的组件可以作为公用的业务组件提取出来, 不单交互是一致的, 而且内部的业务逻辑也是一致的"},{"title":"redux入门","date":"2018-08-19T12:14:09.000Z","url":"/2018/08/19/redux入门/","tags":["react"],"categories":["react"],"content":"Redux是什么Redux对于JavaScript应用而言是一个可预测状态的容器。换言之，它是一个应用数据流框架，而不是传统的像underscore.js或者AngularJs那样的库或者框架。Redux最主要是用作应用状态的管理。简言之，Redux用一个单独的常量状态树（对象）保存这一整个应用的状态，这个对象不能直接被改变。当一些数据变化了，一个新的对象就会被创建（使用actions和reducers）。应用中所有的 state 都以一个对象树的形式储存在一个单一的 store 中。 惟一改变 state 的办法是触发 action，一个描述发生什么的对象。 为了描述 action 如何改变 state 树，你需要编写 reducers (单向数据流)。Redux的优点预测始终有一个准确的数据源，就是store, 对于如何将actions以及应用的其他部分和当前的状态同步可以做到绝不混乱。维护具备可预测结果的性质和严格的组织结构让代码更容易维护。组织对代码应该如何组织更加严苛，这使代码更加一致，对团队协作更加容易。测试编写可测试代码的首要准则就是编写可以仅做一件事并且独立的小函数。Redux的代码几乎全部都是这样的函数：短小、纯粹、分离服务端渲染可以带来更好的用户体验并且有助于搜索引擎优化，尤其是对于首次渲染。仅仅是把服务端创建的store传递给客户端就可以。开发者工具开发者可以实时跟踪在应用中正在发生的一切，从actions到状态的改变。社区与生态圈存在很多支持Redux的社区，使它能够吸引更多的人来使用。Redux的核心概念1. action简单地，Actions就是事件。Actions传递来自这个应用（用户接口，内部事件比如API调用和表单提交）的数据给store。store只获取来自Actions的信息。内部Actions就是简单的具有一个type属性（通常是常量）的JavaScript对象，这个对象描述了action的类型以及传递给store的负载信息。Actions通过action生成器创建，它们仅仅是是返回action的函数。要在应用中的任何地方调用actions很容易，使用dispatch方法。2. reducers在函数式JavaScript中reducer基于数组reduce方法，接收一个回调（reducer）让你从多个值中获得单个值，整数和，或者一个一系列值的累积。在Redux中，reducer就是获得这个应用的当前状态和事件然后返回一个新状态的函数。理解reducer是怎样工作的至关重要，因为它们完成大部分工作。这是一个非常简单的reducer，通过获取当前state和一个action作为参数，再返回下一个state：对于更多复杂的项目，使用Redux提供的combineReducers()实例是必要的（推荐）。它把在这个应用中所有的reducer结合在一起成为单个索引reducer。每一个reducer负责它自己那部分应用的状态，这个状态参数和其他reducer的不一样。combineReducers()实例使文件结构更容易维护。如果一个对象（state）只改变一些值，Redux就创建一个新的对象，那些没有改变的值将会指向旧的对象而且新的值将会被创建。这对性能是极好的。为了让它更有效率你可以添加 Immutable.js3. storeStore对象保存应用的状态并提供一些帮助方法来存取状态，分发状态以及注册监听。全部state由一个store来表示。任何action通过reducer返回一个新的状态对象。这就使得Redux非常简单以及可预测。三大原则单一数据源整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。State是只读的唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。使用纯函数来进行修改state为了描述 action 如何改变 state tree ，你需要编写 reducers。view —&gt; action —&gt; reducer —&gt; store(state) —&gt; view"},{"title":"netlify简介","date":"2018-08-15T07:24:09.000Z","url":"/2018/08/15/netlify简介/","tags":["其他"],"categories":["其他"],"content":"netlifyNetlify优秀的静态博客托管平台-自动编译部署生成Web网站可绑域名支持SSL.netlify则是国外一家提供静态网络托管服务的综合平台，专注于静态网站托管的web服务平台，可以完美的取代Coding。 Netlify完美且免费支持的ssl、域名绑定、http/2和TLS。最重要的就是，管理方式用git方法传递给github、gitlab或者是Bitbucket，然后Netlify就能自动编译并生成静态网站，真的是前端er的福音。1.官方首页：.首先是到netlify申请注册一个账号。这里可以使用Github、Gitlab以及Bitbucket直接授权登陆。然后登录到空间管理中心，点击右上角的“New site from Git”添加网站3.然后根据自己的托管平台，可以选择GitHub、GitLab或者BitBucket。我们以最常用的GitHub为演示例子。（选择GitHub的同学，别忘了勾选下方的“Limit GitHub access to public repositories.”选项）4.点击GitHub之后会弹出一个让你授权的窗口，然后点击“Authorize netlify”之后，就会在netlify中读取你所有的代码库。5.点击你已经建好的库，选好分支（默认master即可），然后点击“Deploy site”，系统就会自动编译你的静态页面了。同时还会给出你的页面二级域名等信息。6.点击创建后，稍等一会儿，你就可以看到Netlify免费静态空间已经创建成功了，同时你在GitHub的代码也成功在Netlify运行了。 快速在Netlify建立Jekyll、Hexo、Hugo静态博客1.开源静态博客程序网站：是Netlify旗下另一个开源的静态博客程序网站，这里汇集了大部分开源的静态博客程序，而Jekyll、Hexo、Hugo等几款常见的博客程序则可以一键部署到Netlify空间上。3.这里以Hexo为例，点击后跳转到Netlify页面，登录你的Github账号。4.命令一个新的项目名称。5.稍等一会儿，Netlify就会自动编译好Hexo博客，完成后如下图所示，你可以直接访问它给的二级域名了：转载自: "},{"title":"react之setState的坑","date":"2018-07-17T08:13:51.000Z","url":"/2018/07/17/react-setState/","tags":["教程"],"categories":["React"],"content":"一.setState今天发现有很多文章在说setState的坑,吐槽之声也不少.其实我就碰到过一个setState不会立即改变数据:所以如果需要获取,就需要在回调函数里去做:这样才会如你所预料那般的输出.二.setState多次,re-render一次这个是我始料未及的了,我一直以为每次setState都会造成一次re-render.其实并不是这样.可以发现,这里只会出现render两次,而不是想象中的4+1(初始化的render).三.总结.1.setState操作,默认情况下是每次调用, 都会re-render一次,除非你手动shouldComponentUpdate为false.2.react为了减少rerender的次数,会进行一个浅合并.将多次re-render减少到一次re-render."},{"title":"Object对象","date":"2018-01-30T03:33:42.000Z","url":"/2018/01/30/ES6/","tags":["教程"],"categories":["ES6"],"content":"Object描述几乎所有的 JavaScript 对象都是 Object 的实例；一个典型的对象继承了Object.prototype的属性（包括方法），尽管这些属性可能被遮蔽（也被称为覆盖）。然而，一个Object可能是故意创建的，这是不确定的（例如通过Object.create(null)），或者它可能被改变，所以这不再是准确的（例如Object.setPrototypeOf）。改变Object原型，会通过原型链，而改变所有对象；除非这些属性和方法被其他对原型链更里层的改动所覆盖。这提供了一个非常强大的、但有潜在危险的机制，来覆盖或扩展对象行为。属性Object.prototype.constructor特定的函数，用于创建一个对象的原型方法 Object.prototypeObject.prototype.hasOwnProperty()返回一个布尔值 ，表示某个对象是否含有指定的属性，而且此属性非原型链继承的。Object.prototype.isPrototypeOf()返回一个布尔值，表示指定的对象是否在本对象的原型链中。Object.prototype.propertyIsEnumerable()判断指定属性是否可枚举，内部属性设置参见 ECMAScript [[Enumerable]] attribute 。Object.prototype.toString()返回对象的字符串表示。Object.prototype.unwatch()移除对象某个属性的监听。Object.prototype.valueOf()返回指定对象的原始值。Object.prototype.watch()给对象的某个属性增加监听。Object方法Object.assign(target, …sources)将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。(注意，Object.assign 会跳过那些值为 null 或 undefined 的源对象。)target: 目标对象。sources: 源对象。针对深拷贝，需要使用其他方法，因为 Object.assign()拷贝的是属性值。假如源对象的属性值是一个指向对象的引用，它也只拷贝那个引用值。Object.create(proto[, propertiesObject])使用指定的原型对象及其属性去创建一个新的对象。"},{"title":"async和await","date":"2017-08-17T11:31:21.000Z","url":"/2017/08/17/ES7/","tags":["教程"],"categories":["ES7"],"content":"async和await在干什么任意一个名称都是有意义的，先从字面意思来理解。async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。另外还有一个很有意思的语法规定，await 只能出现在 async 函数中。然后细心的朋友会产生一个疑问，如果 await 只能出现在 async 函数中，那这个 async 函数应该怎么调用？如果需要通过 await 来调用一个 async 函数，那这个调用的外面必须得再包一个 async 函数，然后……进入死循环，永无出头之日……如果 async 函数不需要 await 来调用，那 async 到底起个啥作用？async起什么作用这个问题的关键在于，async 函数是怎么处理它的返回值的！我们当然希望它能直接通过 return 语句返回我们想要的值，但是如果真是这样，似乎就没 await 什么事了。所以，写段代码来试试，看它到底会返回什么：看到输出就恍然大悟了——输出的是一个 Promise 对象。所以，async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，我们当然应该用原来的方式：then() 链来处理这个 Promise 对象，就像这样现在回过头来想下，如果 async 函数没有返回值，又该如何？很容易想到，它会返回 Promise.resolve(undefined)。联想一下 Promise 的特点——无等待，所以在没有 await 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。那么下一个关键点就在于 await 关键字了。await 到底在等啥一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行await 等到了要等的，然后呢await 等到了它要等的东西，一个 Promise 对象，或者其它值，然后呢？我不得不先说，await 是个运算符，用于组成表达式，await 表达式的运算结果取决于它等的东西。如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。看到上面的阻塞一词，心慌了吧……放心，这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。async/await 帮我们干了啥上面已经说明了 async 会将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象，而 await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。现在举例，用 setTimeout 模拟耗时的异步操作，先来看看不用 async/await 会怎么写如果改用 async/await 呢，会是这样眼尖的同学已经发现 takeLongTime() 没有申明为 async。实际上，takeLongTime() 本身就是返回的 Promise 对象，加不加 async 结果都一样，如果没明白，请回过头再去看看上面的“async 起什么作用”。又一个疑问产生了，这两段代码，两种方式对异步调用的处理（实际就是对 Promise 对象的处理）差别并不明显，甚至使用 async/await 还需要多写一些代码，那它的优势到底在哪？async/await 的优势在于处理 then链单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async/await 来进一步优化它）。假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。我们仍然用 setTimeout 来模拟异步操作：现在用 Promise 方式来实现这三个步骤的处理输出结果 result 是 step3() 的参数 700 + 200 = 900。doIt() 顺序执行了三个步骤，一共用了 300 + 500 + 700 = 1500 毫秒，和 console.time()/console.timeEnd() 计算的结果一致。如果用 async/await 来实现呢，会是这样结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样还有更酷的现在把业务要求改一下，仍然是三个步骤，但每一个步骤都需要之前每个步骤的结果。这回先用 async/await 来写：除了觉得执行时间变长了之外，似乎和之前的示例没啥区别啊！别急，认真想想如果把它写成 Promise 方式实现会是什么样子？有没有感觉有点复杂的样子？那一堆参数处理，就是 Promise 方案的死穴—— 参数传递太麻烦了，看着就晕！洗洗睡吧就目前来说，已经理解 async/await 了吧？但其实还有一些事情没提及——Promise 有可能 reject 啊，怎么处理呢？如果需要并行处理3个步骤，再等待所有结果，又该怎么处理呢？阮一峰老师在ECMAScript 6入门已经说过了，我就懒得说了。"},{"title":"cookie、localStorage、sessionStorage区别","date":"2017-05-27T06:33:42.000Z","url":"/2017/05/27/cookie、localStorage、sessionStorage/","tags":["教程"],"categories":["H5"],"content":"基本概念CookieCookie 是小甜饼的意思。顾名思义，cookie 确实非常小，它的大小限制为4KB左右，是网景公司的前雇员 Lou Montulli 在1993年3月的发明。它的主要用途有保存登录信息，比如你登录某个网站市场可以看到“记住密码”，这通常就是通过在 Cookie 中存入一段辨别用户身份的数据来实现的。localStoragelocalStorage 是 HTML5 标准中新加入的技术，它并不是什么划时代的新东西。早在 IE 6 时代，就有一个叫 userData 的东西用于本地存储，而当时考虑到浏览器兼容性，更通用的方案是使用 Flash。而如今，localStorage 被大多数浏览器所支持，如果你的网站需要支持 IE6+，那以 userData 作为你的 polyfill 的方案是种不错的选择。sessionStoragesessionStorage 与 localStorage 的接口类似，但保存数据的生命周期与 localStorage 不同。做过后端开发的同学应该知道 Session 这个词的意思，直译过来是“会话”。而 sessionStorage 是一个前端的概念，它只是可以将一部分数据在当前会话中保存下来，刷新页面数据依旧存在。但当页面关闭后，sessionStorage 中的数据就会被清空。三者的异同特性CookielocalStoragesessionStorage数据的生命期可设置失效时间，默认是关闭浏览器后失效除非被清除，否则永久保存仅在当前会话下有效，关闭页面或浏览器后被清除存放数据大小4K左右一般为5MB一般为5MB与服务器端通信每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题仅在客户端（即浏览器）中保存，不参与和服务器的通信仅在客户端（即浏览器）中保存，不参与和服务器的通信易用性需要程序员自己封装，源生的Cookie接口不友好源生接口可以接受，亦可再次封装来对Object和Array有更好的支持源生接口可以接受，亦可再次封装来对Object和Array有更好的支持应用场景有了对上面这些差别的直观理解，我们就可以讨论三者的应用场景了。因为考虑到每个 HTTP 请求都会带着 Cookie 的信息，所以 Cookie 当然是能精简就精简啦，比较常用的一个应用场景就是判断用户是否登录。针对登录过的用户，服务器端会在他登录时往 Cookie 中插入一段加密过的唯一辨识单一用户的辨识码，下次只要读取这个值就可以判断当前用户是否登录啦。曾经还使用 Cookie 来保存用户在电商网站的购物车信息，如今有了 localStorage，似乎在这个方面也可以给 Cookie 放个假了~而另一方面 localStorage 接替了 Cookie 管理购物车的工作，同时也能胜任其他一些工作。比如HTML5游戏通常会产生一些本地数据，localStorage 也是非常适用的。如果遇到一些内容特别多的表单，为了优化用户体验，我们可能要把表单页面拆分成多个子页面，然后按步骤引导用户填写。这时候 sessionStorage 的作用就发挥出来了。安全性的考虑需要注意的是，不是什么数据都适合放在 Cookie、localStorage 和 sessionStorage 中的。使用它们的时候，需要时刻注意是否有代码存在 XSS 注入的风险。因为只要打开控制台，你就随意修改它们的值，也就是说如果你的网站中有 XSS 的风险，它们就能对你的 localStorage 肆意妄为。所以千万不要用它们存储你系统中的敏感数据。"},{"title":"webpack学习之路","date":"2017-05-13T07:25:09.000Z","url":"/2017/05/13/webpack学习之路/","tags":["vue"],"categories":["vue"],"content":"webpack学习之路当自己在学习webpack的时候，在网上发现中文的很详细的教程很少，于是便想将自己学习webpack的笔记记录整理下来，便有了这篇文章，希望对大家有所帮助，如果有错误，欢迎大家指出。在我们开始之前webpack有多种加载器(Loader,后面会介绍),可以处理各种需要被处理的静态文件webpack支持CommonJs AMD CMD规范在使用webpack的项目中，默认配置文件为webpack.config.js, 模块文件，和Node写法一样，对外暴露接口,主要属性有:plugins插件项entry入口文件配置项output对应输出项配置module.loaders 最关键的配置，告知webpack不同的文件需要什么加载器进行处理模块系统的几种类型&lt;script&gt;标签类型缺点全局作用域下造成变量的冲文件加载顺序很重要模块与模块之间的依赖要解决在大型项目中难以维护和管理CommonJs优点服务端模块能够重复利用有优秀的包管理工具npm简单，上手容易缺点不适合浏览器端的使用不能做到并行加载模块AMD优点适合浏览器的异步加载机制并行加载模块缺点代码难以经营和维护ES6优点未来的ES规范缺点浏览器对ES6的支持还需要一段时间 能够依赖的现有的模块少‘ 转换 ‘ 的思想 模块要能够在客户端中去执行，则必须将它们从 server =&gt; browser极端的想法:一个请求一个模块 只有需要的模块会被转换，但是耗费资源，时间长所有请求都在一个模块 不需要的模块也会被转换 时间短，耗费资源少分块转换的想法:将众多的模块切成许多片，在初始化时的请求不会包括完整的代码，并且在初始化时不需要的模块切片会在后续加载过程中按需加载。并且将模块化的切片方式是可以有开发人员自己定义的。wepback它的目标是是什么？webpack它能将依赖的模块转化成可以代表这些包的静态文件它的目标有将依赖的模块分片化，并且按需加载解决大型项目初始化加载慢的问题每一个静态文件都可以看成一个模块可以整合第三方库能够在大型项目中运用可以自定义切割模块的方式webpack较之其他类似工具有什么不同？有同步和异步两种不同的加载方式Loader,加载器可以将其他资源整合到JS文件中，通过这种方式，可以讲所有的源文件形成一个模块优秀的语法分析能力，支持 CommonJs AMD 规范有丰富的开源插件库，可以根据自己的需求自定义webpack的配置webpack为什么要将所有资源放在一个文件里面？我们知道，对于浏览器来说，加载的资源越少，响应的速度也就越快，所以有时候我们为了优化浏览器的性能，会尽可能的将资源合并到一个主文件app.js里面。但是这导致的很大的缺点：当你的项目十分庞大的时候，不同的页面不能做到按需加载，而是将所有的资源一并加载，耗费时间长，性能降低。会导致依赖库之间关系的混乱，特别是大型项目时，会变得难以维护和跟踪。比如:哪些文件是需要A模块加载完后才能执行的？哪些页面会受到多个样式表同时影响的？ 等许多问题。而webpack可以很好的解决以上缺点,因为它是一个十分聪明的模块打包系统，当你正确配置后，它会比你想象中的更强大，更优秀。开启wbpack之旅安装webpack我们可以直接使用npm进行全局安装在常规项目中把webpack依赖加入到package.json更详尽的安装方法个可以参考webpack安装webpak命令行常见使用的操作 启动 如果你想当改变一个文件而让webpack实时编译 如果你想把默认的配置文件webpack.config.js改成自定义文件webpack的用法首先先贴上一个比较完整的webpack.config.js的代码，再详细介绍：就像我在前面提到的，webpack.config.js的写法和在Node里的写法相同，我们主要看的就是文件中的module.exports里面的内容entry    是指入口文件的配置项，它是一个数组的原因是webpack允许多个入口点。output是指输出文件的配置项path － 表示输出文件的路径filename - 表示输出文件的文件名plugins 顾名思义，使用插件可以给webpack添加更多的功能，使webpack更加的灵活和强大,webpack有两种类型的插件:webpack内置的插件webpack外置插件比如:更多的插件以及插件的用法，大家可以到webpack的插件上查看。module 配置处理文件的选项loaders 一个含有wepback中能处理不同文件的加载器的数组test 用来匹配相对应文件的正则表达式loaders 告诉webpack要利用哪种加载器来处理test所匹配的文件loaders 的安装方法讲到这里，我相信大家都会对wepback有了更深的认识，但是却十分的松散，不能把它们串起来，那接下来我就用几个小的demo来让大家梳理梳理起来举个例子首先请大家建立一个和我一样文件结构的文件夹，在这里我也说明下这个demo大概要做的事情，就是将css文件都打包放到一个js文件，并且对图片解压，并且要对这个js文件进行自动压缩。 首先看index.html代码再看style.css这个时候我们还没有写webpack.config.js,打开index.html,会看到  打开控制台后，你会发现  接下来，我们在webpack.config.js下加上如下代码  当然，在开始用webpack之前，要先安装相对应的模块，解析css文件 图片文件以及因为要对文件进行压缩，所以也要用到上文中所说的webpack自身内置的插件,所以也要导入webpack模块  安装好之后使用webpack命令后会有这样的提示  但是这个时候你打开浏览器会发现，页面依旧没有什么效果，这是肯定的！我想大家肯定知道下一步该怎么做了，没错！在入口文件里面增加内容再运行webpack,出现上图类似提示后，打开浏览器，你会发现变成了这个样子并且在dist文件夹内，多出了两个文件，一个f1341ce5ea165e06ec3358441b52d5ea.png（随机产生的名字）如果你想获得这个名字，可以将require(&#39;./demo.png&#39;)输出查看，以及还有bundle.js,比较图片前后的大小，可以发现，文件大小发生了改变。打开bundle.js你会发现该文件也被压缩了。是不是感觉很神奇？！还有一个比较好玩的插件htmlwebpackplugin可以点击这里看看，把上面的例子改变下哦。最后我相信看到这里你对webpack一定有了一定的认识，其实webpack还有很多强大的功能，比如，webpack-dev-server可以自动生成一个小型的NodeJs Express服务器从而实现webpack十分实用的功能热替换(HMR) 和其它的工具gulp grunt等一起使用。。。最后值得一提的是react和webpack是一对绝佳cp啊，有木有！！"},{"title":"vue-cli的webpack模板配置目录分析","date":"2017-05-13T04:31:11.000Z","url":"/2017/05/13/vue-cli的webpack模板配置目录分析/","tags":["vue"],"categories":["vue"],"content":"一. 文件结构本文主要分析开发（dev）和构建（build）两个过程涉及到的文件，故下面文件结构仅列出相应的内容。二. 指令分析首先看package.json里面的scripts字段，测试的东西先不看，直接看”dev”和”build”。运行”npm run dev”的时候执行的是build/dev-server.js文件，运行”npm run build”的时候执行的是build/build.js文件，我们可以从这两个文件开始进行代码阅读分析。三. build文件夹分析build/dev-server.js首先来看执行”npm run dev”时候最先执行的build/dev-server.js文件。该文件主要完成下面几件事情：检查node和npm的版本引入相关插件和配置创建express服务器和webpack编译器配置开发中间件（webpack-dev-middleware）和热重载中间件（webpack-hot-middleware）挂载代理服务和中间件配置静态资源启动服务器监听特定端口（8080）自动打开浏览器并打开特定网址（localhost:8080）说明： express服务器提供静态文件服务，不过它还使用了http-proxy-middleware，一个http请求代理的中间件。前端开发过程中需要使用到后台的API的话，可以通过配置proxyTable来将相应的后台请求代理到专用的API服务器。详情请看代码注释：build/webpack.base.conf.js从代码中看到，dev-server使用的webpack配置来自build/webpack.dev.conf.js文件（测试环境下使用的是build/webpack.prod.conf.js，这里暂时不考虑测试环境）。而build/webpack.dev.conf.js中又引用了webpack.base.conf.js，所以这里我先分析webpack.base.conf.js。webpack.base.conf.js主要完成了下面这些事情：配置webpack编译入口配置webpack输出路径和命名规则配置模块resolve规则配置不同类型模块的处理规则说明： 这个配置里面只配置了.js、.vue、图片、字体等几类文件的处理规则，如果需要处理其他文件可以在module.rules里面配置。具体请看代码注释：build/webpack.dev.conf.js接下来看webpack.dev.conf.js，这里面在webpack.base.conf的基础上增加完善了开发环境下面的配置，主要包括下面几件事情：将hot-reload相关的代码添加到entry chunks合并基础的webpack配置使用styleLoaders配置Source Maps配置webpack插件详情请看代码注释：build/utils.js和build/vue-loader.conf.js前面的webpack配置文件中使用到了utils.js和vue-loader.conf.js这两个文件，utils主要完成下面3件事：配置静态资源路径生成cssLoaders用于加载.vue文件中的样式生成styleLoaders用于加载不在.vue文件中的单独存在的样式文件vue-loader.conf则只配置了css加载器以及编译css之后自动添加前缀。详情请看代码注释（下面是vue-loader.conf的代码，utils代码里面原有的注释已经有相应说明这里就不贴出来了）：build/build.js讲完了开发环境下的配置，下面开始来看构建环境下的配置。执行”npm run build”的时候首先执行的是build/build.js文件，build.js主要完成下面几件事：loading动画删除创建目标文件夹webpack编译输出信息说明： webpack编译之后会输出到配置里面指定的目标文件夹；删除目标文件夹之后再创建是为了去除旧的内容，以免产生不可预测的影响。详情请看代码注释：build/webpack.prod.conf.js构建的时候用到的webpack配置来自webpack.prod.conf.js，该配置同样是在webpack.base.conf基础上的进一步完善。主要完成下面几件事情：合并基础的webpack配置使用styleLoaders配置webpack的输出配置webpack插件gzip模式下的webpack插件配置webpack-bundle分析说明： webpack插件里面多了丑化压缩代码以及抽离css文件等插件。详情请看代码：build/check-versions.js和build/dev-client.js最后是build文件夹下面两个比较简单的文件，dev-client.js似乎没有使用到，代码也比较简单，这里不多讲。check-version.js完成对node和npm的版本检测，下面是其代码注释：四. config文件夹分析config/index.jsconfig文件夹下最主要的文件就是index.js了，在这里面描述了开发和构建两种环境下的配置，前面的build文件夹下也有不少文件引用了index.js里面的配置。下面是代码注释：config/dev.env.js、config/prod.env.js和config/test.env.js这三个文件就简单设置了环境变量而已，没什么特别的。五. 总结到这里对模板项目的build和config文件夹下面的内容已经基本了解，知道了在实际使用中根据自己的需求修改哪里的配置，例如，当我有需要配置代理的时候要在config/index.js里面的dev.proxyTable设置，当我修改了资源文件夹名称static同样需要在config/index.js里面设置。总体感觉入门了webpack，但不算真正理解。webpack的插件好多，在看代码的过程中遇到不认识的插件都是要去查看很多文档（github，npm或者博客），感觉实际过程中更改插件配置或者使用新插件也是需要费点心思钻文档和网上其他博客介绍。"},{"title":"canvas和svg","date":"2017-04-24T07:23:22.000Z","url":"/2017/04/24/canvas和svg/","tags":["教程"],"categories":["H5"],"content":"Canvas基于像素单个html,类似于画笔在画布上画画,本身不具备画画功能,js代码就相当于画笔,在画布上画画(通过各种不同的函数)Echarts基于canvas画图01/canvas.htmlSvg基于对象模型多个图形元素高保真01/svg.html"},{"title":"H5规范","date":"2017-03-22T08:13:51.000Z","url":"/2017/03/22/H5/","tags":["教程"],"categories":["H5"],"content":"一.新的DOCTYPE和字符集H5: &lt;!DOCTYPE HTML&gt;H4: &lt;!DOCTYPE html PUBLIC “-//W3C//DTD HTML 4.01//EN”“;　　二.新增语义化标签语义化的简单理解用正确的标签做正确的事情让页面的内容结构化,便于对浏览器,搜索引擎解析在没有CSS情况下也以一种文档格式显示,并且容易阅读使阅读源代码的人更易理解网站分块,便于维护理解利于SEO新增的标签1.header: 表示页眉2.footer: 表示页脚3.hgroup: 表示标题,里面放几个h1-h6元素4.nav: 导航栏5.aside: 主要内容的附属信息(侧边栏)6.section: 节 或者 段7.article: 表示在文档中,页面或网站中自成一体的内容8.address: 表示区块容器,必须作为联系信息出现三.canvas API 和 SVGcanvas元素: 我们可以通过javascript来自由控制它,在里面加图片,线条以及文字,大大丰富了玉面的表现,在画布里绘图,甚至动画SVG: 另外一种图形功能,可以缩放矢量图形,一种二维图形表示语言四.audio和video标签开发人员不必使用插件就能播放视频和音频五.地理定位API六.跨文档消息通信和XHR Level 2七.Forms APIH5的表单增强了很多:主要分为两类新的输入型表单空间新的函数特征八.拖放九.Wev Worker API由于javascript是单线程的,因此长时间的计算会阻塞UI线程,该问题的解决方案是,H5 Web Worker能够让web应用程序可以充分利用多核CPU的优势,将耗时长的任务分配给Worker执行,可以避免弹出脚本运行缓慢的警告,但是Web Worker不能直接访问Web页面和DOM API十.Web Storage API在浏览器里面,H5出现之前,大多使用cookie在客户端存储数据,但是数据量不大,一般为4K ,而storage提供更大的存储,一般为5M"},{"title":"let和const","date":"2017-03-17T06:33:42.000Z","url":"/2017/03/17/let和const/","tags":["教程"],"categories":["ES6"],"content":"let和const命令let 和 const 的新特性:不存在变量提升暂时性死区不允许重复声明块级作用域let命令基本用法ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。for循环的计数器，就很合适使用let命令。上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。下面的代码如果使用var，最后输出的是10。上面代码中，变量i是var声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮的i的值，也就是10。而如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。有些“死区”比较隐蔽，不太容易发现。上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。另外，下面的代码也会报错，与var的行为不同。上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。不允许重复声明let不允许在相同作用域内，重复声明同一个变量。因此，不能在函数内部重新声明参数。块级作用域为什么需要块级作用域？ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景，内层变量可能会覆盖外层变量。上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。第二种场景，用来计数的循环变量泄露为全局变量。上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。ES6 允许块级作用域的任意嵌套。上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。内层作用域可以定义外层作用域的同名变量。块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。块级作用域与函数声明函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。上面两种函数声明，根据 ES5 的规定都是非法的。但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。允许在块级作用域内声明函数。函数声明类似于var，即会提升到全局作用域或函数作用域的头部。同时，函数声明还会提升到所在的块级作用域的头部。注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。do 表达式本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。上面代码中，变量x会得到整个块级作用域的返回值。const 命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。上面代码表明改变常量的值会报错。const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。上面代码表示，对于const来说，只声明不赋值，就会报错。const的作用域与let命令相同：只在声明所在的块级作用域内有效。const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。上面代码在常量MAX声明之前就调用，结果报错。const声明的常量，也与let一样不可重复声明。本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。下面是另一个例子。上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。如果真的想将对象冻结，应该使用Object.freeze方法。上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有6种声明变量的方法。顶层对象的属性顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。global 对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。Node 里面，顶层对象是global，但其他环境都不支持。同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。不管是严格模式，还是普通模式，new Function(&#39;return this&#39;)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。垫片库system.global模拟了这个提案，可以在所有环境拿到global。上面代码可以保证各种环境里面，global对象都是存在的。上面代码将顶层对象放入变量global。"},{"title":"axios","date":"2017-03-11T11:21:35.000Z","url":"/2017/03/11/axios/","tags":["教程"],"categories":["axios"],"content":"一. 安装1、 利用npm安装npm install axios --save2、 利用bower安装bower install axios --save3、 直接利用cdn引入&lt;script src=&quot;;二. 例子1.发送一个GET请求2.发送一个POST请求3.一次性并发多个请求三. axios的API（一） axios可以通过配置（config）来发送请求1.axios(config)2.axios(url[,config])（二）请求方式的别名，这里对所有已经支持的请求方式都提供了方便的别名注意：当我们在使用别名方法的时候，url,method,data这几个参数不需要在配置中声明（三）并发请求（concurrency）,即是帮助处理并发请求的辅助函数（四）创建一个axios实例，并且可以自定义其配置1.axios.create([config])2.实例的方法以下是实例方法，注意已经定义的配置将和利用create创建的实例的配置合并四. 请求的配置（request config）以下就是请求的配置选项，只有url选项是必须的，如果method选项未定义，那么它默认是以GET的方式发出请求五. 请求返回的内容你可以这样来获取响应信息六. 默认配置你可以设置默认配置，对所有请求都有效1.全局默认配置axios.defaults.baseURL = ‘[‘Authorization’] = AUTH_TOKEN;axios.defaults.headers.post[‘content-Type’] = ‘appliction/x-www-form-urlencoded’;2.自定义的实例默认设置3.配置中的有优先级config配置将会以优先级别来合并，顺序是lib/defauts.js中的默认配置，然后是实例中的默认配置，最后是请求中的config参数的配置，越往后等级越高，后面的会覆盖前面的例子。七. 拦截器你可以在请求、响应在到达then/catch之前拦截他们1.添加一个请求拦截器2、取消拦截器3、 给自定义的axios实例添加拦截器八. 错误处理九. 取消你可以通过一个cancel token来取消一个请求你可以通过CancelToken.source工厂函数来创建一个cancel token"},{"title":"AngularJS","date":"2016-08-30T02:06:41.000Z","url":"/2016/08/30/angularjs/","tags":["angularjs"],"categories":["angularjs"],"content":"Angularjs是什么AngularJS是一个功能强大的基于JavaScript开发框架用于创建富互联网应用(RIA)。Angularjs的核心特性数据绑定： 模型和视图组件之间的数据自动同步。适用范围： 这些对象参考模型。它们充当控制器和视图之间的胶水。控制器： 　这些Javascript函数绑定到特定的范围。服务： 　　AngularJS配有多个内置服务，例如 $http 可作为一个XMLHttpRequest请求。这些单一对象在应用程序只实例化一次。过滤器： 　从一个数组的条目中选择一个子集，并返回一个新的数组。指令： 　　指令是关于DOM元素标记(如元素，属性，CSS等等)。这些可以被用来创建作为新的，自定义部件的自定义HTML标签。AngularJS设有内置指令(如：ngBind，ngModel…)模板：　　 这些符合从控制器和模型信息的呈现的视图。这些可以是单个文件(如index.html)，或使用“谐音”在一个页面多个视图。路由： 　　它是切换视图的概念。模型视图： MVC是一个设计模式将应用划分为不同的部分(称为模型，视图和控制器)，每个都有不同的职责。 AngularJS并没有传统意义上的实现MVC，而是更接近于MVVM(模型 - 视图 - 视图模型)。 AngularJS团队将它作为模型视图。深层链接： 深层链接，可以使应用程序状态进行编码在URL中而能够添加到书签。应用程序可从URL恢复到相同的状态。依赖注入: AngularJS有一个内置的依赖注入子系统，开发人员通过使应用程序从而更易于开发，理解和测试。AngularJS的优点AngularJS提供一个非常干净和维护的方式来创造单页的应用。 AngularJS提供数据绑定功能在HTML中，从而给用户提供丰富和响应的体验 AngularJS代码可进行单元测试。 AngularJS使用依赖注入和利用关注点分离。 AngularJS提供了可重用的组件。 使用AngularJS，开发人员编写更少的代码，并获得更多的功能。 在AngularJS中，视图都是纯HTML页面，并用JavaScript编写控制器做业务处理。AngularJS应用程序可以在所有主要的浏览器和智能手机，包括Android和iOS系统的手机/平板电脑上运行。AngulaJS的缺点不安全：因为只是JavaScript一种框架，由AngularJS编写的应用程序是不安全的。服务器端身份验证和授权是必须用来保证应用程序的安全。不可降解：如果应用程序的用户禁用JavaScript，那最后用户看到的只是基本页面，仅此而已。示例包括AngularJS我们已经包括了AngularJS的JavaScript文件到HTML页面中，所以我们可以用AngularJS：指向AngularJS应用程序接下来我们需要指示HTML的哪一部分包含了AngularJS应用程序。这可以通过ng-app属性到AngularJS应用程序的根HTML元素。可以把它添加到HTML元素或body元素，如下所示：视图ng-controller 告诉AngularJS什么控制器使用在视图中。helloTo.title告诉AngularJS将命名helloTo.title的值写入到HTML的“model”中。控制器此代码注册一个名为HelloController的控制器功能，在myapp模块。 我们将学习更多关于它们在各自的模块和控制器章节。控制器函数注册在Angular中，通过angular.module(…).controller(…) 的函数来调用。 传递给控制器函数的$scope参数是模型。控制器函数增加了helloTo的 JavaScript对象，并在该对象它增加了一个标题字段。AngularJS 控制器略AngularJS 过滤器内置过滤器uppercase：转换文本为大写文字。lowercase：转换文本为小写文字。currency：以货币格式格式化文本。filter：过滤数组到根据提供标准的一个子集。orderby：排序基于提供标准的数组。AngularJS HTML DOMng-disabled：     禁用给定的控制ng-show：     显示了一个给定的控制ng-hide：     隐藏一个给定的控制ng-click：     表示一个AngularJS click事件AngularJS 模块AngularJS支持模块化方法。模块用于单独的逻辑表示服务，控制器，应用程序等。为保持代码简洁，我们在单独的 js 文件中定义模块，并将其命名为 module.js文件。 在这个例子中，我们要创建两个模块。应用模块 - 控制器用于初始化应用程序。控制器模块 - 用于定义控制器。应用模块在这里，我们声明了使用 angular.module 函数的应用程序mainApp模块。我们已经传递一个空数组给它。这个数组通常包含依赖模块。控制器模块"},{"title":"node.js 事件驱动编程理解","date":"2016-04-12T06:33:42.000Z","url":"/2016/04/12/node.js 事件驱动编程理解/","tags":["nodejs"],"categories":["nodejs"],"content":"理解Node.js事件驱动编程　　Node.js现在非常活跃，相关生态社区已经超过Lua（基本上比较知名的功能都有nodejs模块实现）。　　但是我们为何要使用Node.Js？相比传统的webserver服务模式，nodejs有什么优点优势？Node.Js是基于javascript语言，建构在google V8 engine以及Linux上的一个非阻塞事件驱动IO框架。nodejs是单进程单线程，但是基于V8的强大驱动力，以及事件驱动模型，nodejs的性能非常高，而且想达到多核或者多进程也不是很难（现在已经有大量的第三方module来实现这个功能）。　　这里主要不是介绍nodejs具体应用代码，而是想介绍一下事件驱动编程。医生看病　　在美国去看医生，需要填写大量表格，比如保险、个人信息之类，传统的基于线程的系统（thread-based system），接待员叫到你，你需要在前台填写完成这些表格，你站着填单，而接待员坐着看你填单。你让接待员没办法接待下一个客户，除非完成你的业务。　　想让这个系统能运行的快一些，只有多加几个接待员，人力成本需要增加不少。　　基于事件的系统（event-based system）中，当你到窗口发现需要填写一些额外的表格而不仅仅是挂个号，接待员把表格和笔给你，告诉你可以找个座位填写，填完了以后再回去找他。你回去坐着填表，而接待员开始接待下一个客户。你没有阻塞接待员的服务。　　你填完表格，返回队伍中，等接待员接待完现在的客户，你把表格递给他。如果有什么问题或者需要填写额外的表格，他给你一份新的，然后重复这个过程。　　这个系统已经非常高效了，几乎大部分医生都是这么做的。如果等待的人太多，可以加入额外的接待员进行服务，但是肯定要比基于线程模式的少得多。快餐店点餐　　在基于线程的方式中（thread-based way）你到了柜台前，把你的点餐单给收银员或者给收银员直接点餐，然后等在那直到你要的食物准备好给你。收银员不能接待下一个人，除非你拿到食物离开。想接待更多的客户，容易！加更多的收银员！　　当然，我们知道快餐店其实不是这样工作的。他们其实就是基于事件驱动方式，这样收银员更高效。只要你把点餐单给收银员，某个人已经开始准备你的食物，而同时收银员在进行收款，当你付完钱，你就站在一边而收银员已经开始接待下一个客户。在一些餐馆，甚至会给你一个号码，如果你的食物准备好了，就呼叫你的号码让你去柜台取。关键的一点是，你没有阻塞下一个客户的订餐请求。你订餐的食物做好的事件会导致某个人做某个动作（某个服务员喊你的订单号码，你听到你的号码被喊到去取食物），在编程领域，我们称这个为回调（callback function）。Node.Js做了什么工作呢　　传统的web server多为基于线程模型。你启动Apache或者什么server，它开始等待接受连接。当收到一个连接，server保持连接连通直到页面或者什么事务请求完成。如果他需要花几微妙时间去读取磁盘或者访问数据库，web server就阻塞了IO操作（这也被称之为阻塞式IO).想提高这样的web server的性能就只有启动更多的server实例。　　相反的，Node.Js使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）　　考虑下面这个过程：1.你用浏览器访问nodejs服务器上的”/about.html”2.nodejs服务器接收到你的请求，调用一个函数从磁盘上读取这个文件。3.这段时间，nodejs webserver在服务后续的web请求。4.当文件读取完毕，有一个回调函数被插入到nodejs的服务队列中。5.nodejs webserver运行这个函数，实际上就是渲染（render）了about.html页面返回给你的浏览器。　　好像就节省了几微秒时间，但是这很重要！特别是对于需要相应大量用户的web server。　　这也就是为什么Node.Js这么热这么惹人关注。而且它还使用了一个非常通用的编程语言Javascript，也让开发者可以快速容易的编写高可扩展性服务器。"},{"title":"node基础","date":"2016-03-15T06:33:42.000Z","url":"/2016/03/15/node基础/","tags":["nodejs"],"categories":["nodejs"],"content":"Node服务器端开发第一天Node简介及配置、快速上手、核心特点、模块化Node简介客户端的JavaScript是怎样的什么是 JavaScript？脚本语言运行在浏览器中一般用来做客户端页面的交互（Interactive）JavaScript 的运行环境？是不是运行在浏览器呢？不够严谨运行在浏览器内核中的 JS 引擎（engine）浏览器中的 JavaScript 可以做什么？操作DOM（对DOM的增删改、注册事件）AJAX/跨域BOM（页面跳转、历史记录、console.log()、alert()）ECMAScript浏览器中的 JavaScript 不可以做什么？文件操作（文件和文件夹的CRUD）没有办法操作系统信息由于运行环境特殊（我们写的代码是在不认识的人的浏览器中运行）在开发人员能力相同的情况下编程语言的能力取决于什么？-语言本身？-语言本身只是提供定义变量，定义函数，定义类型，流程控制，循环结构之类的操作取决于运行该语言的平台（环境）对于JS来说，我们常说的JS实际是ES，大部分能力都是由浏览器的执行引擎决定BOM和DOM可以说是浏览器开放出来的接口比如：Cordova中提供JS调用摄像头，操作本地文件的APIJava既是语言也是平台Java运行在Java虚拟机（跨操作系统）PHP既是语言也是平台（跨操作系统）C#语言平台：.NET Framework（Windows）C#可以运行在MONO这样的平台因为有人需要将C#运行在Linux平台，所有出现了MONOJavaScript 只可以运行在浏览器中吗？不是能运行在哪取决于，这个环境有没有特定平台什么是NodeNode 就是 JavaScript 语言在服务器端的运行环境所谓“运行环境（平台）”有两层意思：首先，JavaScript 语言通过 Node 在服务器运行，在这个意义上，Node 有点像 JavaScript 虚拟机；其次，Node 提供大量工具库，使得 JavaScript 语言与操作系统互动（比如读写文件、新建子进程），在这个意义上， Node 又是 JavaScript 的工具库。为什么是JavaScriptNode的实现结构Node在当下Web开发领域的应用哪些公司在用重点理解Node是一个JavaScript的运行环境（平台），不是一门语言，也不是JavaScript的框架；Node的实现结构；Node可以用来开发服务端应用程序，Web系统；基于Node的前端工具集环境配置安装包的方式安装安装包下载链接：Mac OSX： darwinWindows：x64x86安装操作：一路Next更新版本操作方式：重新下载最新的安装包；覆盖安装即可；问题：以前版本安装的很多全局的工具包需要重新安装无法回滚到之前的版本无法在多个版本之间切换（很多时候我们要使用特定版本）NVM工具的使用Node Version Manager（Node版本管理工具）由于以后的开发工作可能会在多个Node版本中测试，而且Node的版本也比较多，所以需要这么款工具来管理安装操作步骤下载：nvm-windows解压到一个全英文路径编辑解压目录下的settings.txt文件（不存在则新建）root 配置为当前 nvm.exe 所在目录path 配置为 node 快捷方式所在的目录arch 配置为当前操作系统的位数（32/64）proxy 不用配置配置环境变量 可以通过 window+r  : sysdm.cplNVM_HOME = 当前 nvm.exe 所在目录NVM_SYMLINK = node 快捷方式所在的目录PATH += %NVM_HOME%;%NVM_SYMLINK%;打开CMD通过set [name]命令查看环境变量是否配置成功PowerShell中是通过dir env:[name]命令NVM使用说明：的目录之后使用再配置配置Python环境Node中有些第三方的包是以C/C++源码的方式发布的，需要安装后编译确保全局环境中可以使用python命令环境变量的概念环境变量就是操作系统提供的系统级别用于存储变量的地方Windows中环境变量分为系统变量和用户变量环境变量的变量名是不区分大小写的特殊值：PATH 变量：只要添加到 PATH 变量中的路径，都可以在任何目录下搜索Windows下常用的命令行操作切换当前目录（change directory）：cd创建目录（make directory）：mkdir查看当前目录列表（directory）：dir别名：ls（list）清空当前控制台：cls别名：clear删除文件：del别名：rm注意：所有别名必须在新版本的 PowerShell 中使用快速上手dirname: 当前文件的绝对路径filename: 当前文件的绝对路径加当前文件名事件驱动和非阻塞模块化开发"},{"title":"markdown语法学习","date":"2015-10-23T06:21:35.000Z","url":"/2015/10/23/markdown语法/","tags":["教程"],"categories":["markdown"],"content":"Markdown是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。Markdown的语法简洁明了、学习容易，而且功能比纯文本更强，因此有很多人用它写博客。 ——百度百科0. 编辑器有许多的Markdown编辑器,个人比较了很多款,觉得这两款不错 :马克飞象 作业部落 ——可在线使用,可下载客户端使用 ; 左边书写,右边即时预览 .以下为11种基本语法:1. 标题2. 粗体3. 斜体4. 无序列表5. 有序列表6. 链接7. 图片8. 引用框9. 代码10. 脚注11. 分割线另. 下划线另外. 转义字符 ——斜杠"},{"title":"Hello World","date":"2015-06-23T06:21:35.000Z","url":"/2015/06/23/hello-world/","tags":["教程"],"content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.Quick StartCreate a new postMore info: WritingRun serverMore info: ServerGenerate static filesMore info: GeneratingDeploy to remote sitesMore info: Deployment"}]